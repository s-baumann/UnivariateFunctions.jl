<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · UnivariateFunctions</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">UnivariateFunctions</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><ul><li><a href="#UnivariateFunctions.PE_Function"><code>UnivariateFunctions.PE_Function</code></a></li><li><a href="#UnivariateFunctions.Piecewise_Function"><code>UnivariateFunctions.Piecewise_Function</code></a></li><li><a href="#UnivariateFunctions.Sum_Of_Functions"><code>UnivariateFunctions.Sum_Of_Functions</code></a></li><li><a href="#UnivariateFunctions.Undefined_Function"><code>UnivariateFunctions.Undefined_Function</code></a></li><li><a href="#UnivariateFunctions.UnivariateFunction"><code>UnivariateFunctions.UnivariateFunction</code></a></li><li><a href="#SchumakerSpline.evaluate"><code>SchumakerSpline.evaluate</code></a></li><li><a href="#SchumakerSpline.evaluate_integral"><code>SchumakerSpline.evaluate_integral</code></a></li><li><a href="#UnivariateFunctions.change_base_of_PE_Function"><code>UnivariateFunctions.change_base_of_PE_Function</code></a></li><li><a href="#UnivariateFunctions.convert_to_linearly_rescale_inputs"><code>UnivariateFunctions.convert_to_linearly_rescale_inputs</code></a></li><li><a href="#UnivariateFunctions.create_chebyshev_approximation"><code>UnivariateFunctions.create_chebyshev_approximation</code></a></li><li><a href="#UnivariateFunctions.create_constant_interpolation_to_left"><code>UnivariateFunctions.create_constant_interpolation_to_left</code></a></li><li><a href="#UnivariateFunctions.create_constant_interpolation_to_right"><code>UnivariateFunctions.create_constant_interpolation_to_right</code></a></li><li><a href="#UnivariateFunctions.create_linear_interpolation"><code>UnivariateFunctions.create_linear_interpolation</code></a></li><li><a href="#UnivariateFunctions.create_ols_approximation"><code>UnivariateFunctions.create_ols_approximation</code></a></li><li><a href="#UnivariateFunctions.create_quadratic_spline"><code>UnivariateFunctions.create_quadratic_spline</code></a></li><li><a href="#UnivariateFunctions.derivative"><code>UnivariateFunctions.derivative</code></a></li><li><a href="#UnivariateFunctions.get_chevyshevs_up_to"><code>UnivariateFunctions.get_chevyshevs_up_to</code></a></li><li><a href="#UnivariateFunctions.indefinite_integral"><code>UnivariateFunctions.indefinite_integral</code></a></li><li><a href="#UnivariateFunctions.left_integral"><code>UnivariateFunctions.left_integral</code></a></li><li><a href="#UnivariateFunctions.period_length"><code>UnivariateFunctions.period_length</code></a></li><li><a href="#UnivariateFunctions.right_integral"><code>UnivariateFunctions.right_integral</code></a></li><li><a href="#UnivariateFunctions.trim_piecewise_function"><code>UnivariateFunctions.trim_piecewise_function</code></a></li><li><a href="#UnivariateFunctions.years_between"><code>UnivariateFunctions.years_between</code></a></li><li><a href="#UnivariateFunctions.years_from_global_base"><code>UnivariateFunctions.years_from_global_base</code></a></li></ul><h3 id="Main-Structs"><a class="docs-heading-anchor" href="#Main-Structs">Main Structs</a><a id="Main-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Structs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.UnivariateFunction" href="#UnivariateFunctions.UnivariateFunction"><code>UnivariateFunctions.UnivariateFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnivariateFunction</code></pre><p>An abstract type. The concrete structs that have been implemented are Undefined<em>Function,     PE</em>Function, Sum<em>Of</em>Functions, Piecewise_Function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.Undefined_Function" href="#UnivariateFunctions.Undefined_Function"><code>UnivariateFunctions.Undefined_Function</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Undefined_Function &lt;: UnivariateFunction</code></pre><p>This function throws an error if you ever try to evaluate it. Think of it as doing the role of missing but for UnivariateFunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.PE_Function" href="#UnivariateFunctions.PE_Function"><code>UnivariateFunctions.PE_Function</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PE_Function{F&lt;:Real,I&lt;:Integer} &lt;: UnivariateFunction</code></pre><p>This function has the functional form:     a exp(b(x-base)) (x-base)^d Where a,b,base are floats and d is a positive integer. These four are the  members of the struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.Sum_Of_Functions" href="#UnivariateFunctions.Sum_Of_Functions"><code>UnivariateFunctions.Sum_Of_Functions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sum_Of_Functions &lt;: UnivariateFunction</code></pre><p>This function contants a vector of UnivariateFunctions. When evaluted it adds the evaluations of these functions and returns the sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.Piecewise_Function" href="#UnivariateFunctions.Piecewise_Function"><code>UnivariateFunctions.Piecewise_Function</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Piecewise_Function &lt;: UnivariateFunction</code></pre><p>This function contants a vector of locations in the x space and a vector of UnivariateFunctions. When evaludated it uses these vectors as a lookup. It chooses the correct UnivariateFunction and evaluates it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L84-L90">source</a></section></article><h3 id="Function-Evaluation-and-Calculus"><a class="docs-heading-anchor" href="#Function-Evaluation-and-Calculus">Function Evaluation and Calculus</a><a id="Function-Evaluation-and-Calculus-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Evaluation-and-Calculus" title="Permalink"></a></h3><p>Note that in addition to the below functions the following operators:</p><p><code>+</code>, <code>-</code>, <code>\</code>, <code>*</code>, <code>^</code></p><p>have also been overloaded so that a function will be returned with the analytical sum, difference, product, quotient, power. The restrictions are that you cannot divide by a function (although you can divide by a scalar) and only positive integer powers can be taken.</p><article class="docstring"><header><a class="docstring-binding" id="SchumakerSpline.evaluate" href="#SchumakerSpline.evaluate"><code>SchumakerSpline.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate(f::UnivariateFunction, r::Real)
evaluate(f::UnivariateFunction, d::Union{Date,DateTime})
evaluate(f::UnivariateFunction, x::DatePeriod)</code></pre><p>This evaluates the function at the requested point. If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>years_from_global_base</code> function. <code>DatePeriod</code>s are converted with the <code>period_length</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L270-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.derivative" href="#UnivariateFunctions.derivative"><code>UnivariateFunctions.derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">derivative(f::UnivariateFunction)</code></pre><p>This calculates the derivative of the function and returns it as a <code>UnivariateFunction</code>.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/1_undefined_function.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.indefinite_integral" href="#UnivariateFunctions.indefinite_integral"><code>UnivariateFunctions.indefinite_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indefinite_integral(f::UnivariateFunction)</code></pre><p>This calculates the indefinite integral of a <code>UnivariateFunction</code>.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/1_undefined_function.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SchumakerSpline.evaluate_integral" href="#SchumakerSpline.evaluate_integral"><code>SchumakerSpline.evaluate_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_integral(f::UnivariateFunction,left::Real, right::Real)
evaluate_integral(f::UnivariateFunction,left::Union{Date,DateTime}, right::Union{Date,DateTime})</code></pre><p>This calculates the integral of a function from a left limit to a right limit and returns a scalar.</p><p>If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>years_from_global_base</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>left</code> - A left limit (scalar)</li><li><code>right</code> - A right limit (scalar)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/5_calculus.jl#L113-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.right_integral" href="#UnivariateFunctions.right_integral"><code>UnivariateFunctions.right_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">right_integral(f::UnivariateFunction, left::Real)
right_integral(f::UnivariateFunction, left::Union{Date,DateTime})</code></pre><p>This calculates the integral of a function from a left limit and returns it as a UnivariateFunction. So if you were to then evaluate this integral function at a point x then you would get the integral between left and x.</p><p>If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>years_from_global_base</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>left</code> - A left limit (scalar)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/5_calculus.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.left_integral" href="#UnivariateFunctions.left_integral"><code>UnivariateFunctions.left_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">left_integral(f::UnivariateFunction, right::Real)
left_integral(f::UnivariateFunction, right::Union{Date,DateTime})</code></pre><p>This calculates the integral of a function from a right limit and returns it as a UnivariateFunction. So if you were to then evaluate this integral function at a point x then you would get the integral between right and x.</p><p>If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>years_from_global_base</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>right</code> - A right limit (scalar)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/5_calculus.jl#L59-L74">source</a></section></article><h3 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.create_quadratic_spline" href="#UnivariateFunctions.create_quadratic_spline"><code>UnivariateFunctions.create_quadratic_spline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_quadratic_spline(x::Union{Vector{DateTime},Vector{Date},Vector{Union{Date,DateTime}}},y::Vector{&lt;:Real} ; gradients::Union{Missing,Vector{&lt;:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),
                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing)
create_quadratic_spline(x::Vector{&lt;:Real},y::Vector{&lt;:Real} ; gradients::Union{Missing,Array{&lt;:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),
                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing)
create_quadratic_spline(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}; gradients::Union{Missing,Vector{&lt;:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),
                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing) where D&lt;:DatePeriod</code></pre><p>Makes a quadratic shape-preserving interpolation spline using the SchumakerSpline.jl package. This is returned as a <code>Piecewise_Function</code> rather than as a <code>Schumaker</code> struct.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li><li><code>gradients</code> - A <code>Vector</code> with the gradiants at each x location. This is calculated if not provided.</li><li><code>extrapolation</code> - A tuple of enum value describing how to extrapolate (on the left and right sides).</li><li><code>left_gradient</code> - The gradiant to impose on the left edge (ie the first x coordinate).</li><li><code>right_gradient</code> - The gradiant to impose on the right edge (ie the last x coordinate).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the spline.</li></ul><pre><code class="nohighlight hljs">create_quadratic_spline(schum::Schumaker)</code></pre><p>This converts a spline represented by a <code>SchumakerSpline.Schumaker</code> struct into the same spline but represented by a <code>Piecewise_Function</code>.</p><p><strong>Inputs</strong></p><ul><li><code>schum</code> - A <code>Schumaker</code> struct.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/6_splines_and_interpolation.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.create_constant_interpolation_to_right" href="#UnivariateFunctions.create_constant_interpolation_to_right"><code>UnivariateFunctions.create_constant_interpolation_to_right</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_constant_interpolation_to_right(x::Vector{Date},y::Vector{&lt;:Real})
create_constant_interpolation_to_right(x::Vector{&lt;:Real},y::Vector{&lt;:Real})
create_constant_interpolation_to_right(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}) where D&lt;:DatePeriod</code></pre><p>Makes a piecewise constant interpolation function. values from the left are copied to the right.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the interpolation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/6_splines_and_interpolation.jl#L60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.create_constant_interpolation_to_left" href="#UnivariateFunctions.create_constant_interpolation_to_left"><code>UnivariateFunctions.create_constant_interpolation_to_left</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_constant_interpolation_to_left(x::Vector{Date},y::Vector{&lt;:Real})
create_constant_interpolation_to_left(x::Vector{&lt;:Real},y::Vector{&lt;:Real})
create_constant_interpolation_to_left(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}) where D&lt;:DatePeriod</code></pre><p>Makes a piecewise constant interpolation function. values from the right are copied to the left.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the interpolation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/6_splines_and_interpolation.jl#L89-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.create_linear_interpolation" href="#UnivariateFunctions.create_linear_interpolation"><code>UnivariateFunctions.create_linear_interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_linear_interpolation(x::Vector{Date},y::Vector{&lt;:Real})
create_linear_interpolation(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}) where D&lt;:DatePeriod
create_linear_interpolation(x::Vector{R},y::Vector{&lt;:Real}) where R&lt;:Real</code></pre><p>Makes a piecewise linear interpolation function. This is continuous.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the interpolation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/6_splines_and_interpolation.jl#L118-L129">source</a></section></article><h3 id="Approximation"><a class="docs-heading-anchor" href="#Approximation">Approximation</a><a id="Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.create_ols_approximation" href="#UnivariateFunctions.create_ols_approximation"><code>UnivariateFunctions.create_ols_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_ols_approximation(y::Vector{&lt;:Real}, x::Vector{&lt;:Real}, base_x::Real = 0.0, degree::Integer = 1, intercept::Bool = true)
create_ols_approximation(y::Vector{&lt;:Real}, x::Union{Vector{DateTime},Vector{Date},Vector{Union{Date,DateTime}}}, base_x::Union{Date,DateTime} = global_base_date, degree::Integer = 1, intercept::Bool = true)</code></pre><p>An approximation function calculated via OLS.</p><p><strong>Inputs</strong></p><ul><li><code>y</code> - A <code>Vector</code> with the y coordinates</li><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>base_x</code> - A real that offsets the x. So a coordinate with x value of 2.0 will be converted to 1.8 if base_x is 0.2.</li><li><code>degree</code> - What the highest power of x should be. So if this is 3 then the equation will have x, x^2, x^3 as predictors.</li><li><code>intercept</code> - Should there be an x intercept.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Sum_Of_Functions</code> containing the approximation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/7_regressions_and_approximation.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.create_chebyshev_approximation" href="#UnivariateFunctions.create_chebyshev_approximation"><code>UnivariateFunctions.create_chebyshev_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_chebyshev_approximation(func::Function, nodes::Integer, degree::Integer, left::Real, right::Real)</code></pre><p>An function that will approximate another function via Chebyshev polynomials.</p><p><strong>Inputs</strong></p><ul><li><code>func</code> - A function that you want to approximation</li><li><code>nodes</code> - The number of approximation nodes</li><li><code>degree</code> - The degree of the Chebyshev polynomials.</li><li><code>left</code> - The left limit of the approximation</li><li><code>right</code> - The right limit of the approximation.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Sum_Of_Functions</code> containing the approximation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/7_regressions_and_approximation.jl#L59-L72">source</a></section></article><h3 id="Internal-Functions-2"><a class="docs-heading-anchor" href="#Internal-Functions-2">Internal Functions</a><a class="docs-heading-anchor-permalink" href="#Internal-Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.change_base_of_PE_Function" href="#UnivariateFunctions.change_base_of_PE_Function"><code>UnivariateFunctions.change_base_of_PE_Function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">change_base_of_PE_Function(f::PE_Function, new_base::Real)</code></pre><p>This changes the base of a <code>PE_Function</code>. So if the base was 2 then it can be converted to 3 with an additional constant term.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>PE_Function</code>.</li><li><code>new_base</code> - The new base.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>PE_Function</code> or a <code>Sum_Of_Functions</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L305-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.trim_piecewise_function" href="#UnivariateFunctions.trim_piecewise_function"><code>UnivariateFunctions.trim_piecewise_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim_piecewise_function(func::Piecewise_Function, left_limit::Real, right_limit::Real)</code></pre><p>This trims the end of a piecewise function. So if there is a piecewise function with support between -10,10 then you can trim it to only have support between -5 and 5. Then if it is evaluated outside -5 to 5 it will be undefined.</p><p><strong>Inputs</strong></p><ul><li><code>func</code> - A Piecewise_Function.</li><li><code>left_limit</code> - The left limit.</li><li><code>right_limit</code> - The right limit.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L124-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.convert_to_linearly_rescale_inputs" href="#UnivariateFunctions.convert_to_linearly_rescale_inputs"><code>UnivariateFunctions.convert_to_linearly_rescale_inputs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_to_linearly_rescale_inputs(f::UnivariateFunction, alpha::Real, beta::Real)</code></pre><p>This alters a function so that whenever we put in x it is like we put in <code>alpha * x + beta</code>.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>alpha</code> - The slope of the rescaling.</li><li><code>beta</code> - The level of the rescaling.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code> of the type that you input to the function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/0_structs_and_generic_reversals.jl#L344-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.get_chevyshevs_up_to" href="#UnivariateFunctions.get_chevyshevs_up_to"><code>UnivariateFunctions.get_chevyshevs_up_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_chevyshevs_up_to(N::Integer, first_kind::Bool = true)</code></pre><p>Get the first N chebyshev polynomials returned as a vector of <code>UnivariateFunction</code>s. The first 20 polynomials of each are precompiled into the binaries for speed. If you need more than that they will be calculated at runtime.</p><p>These can be from either the first kind or second kind polynomial sequence.</p><p><strong>Inputs</strong></p><ul><li><code>N</code> - How many chebyshev polynomials do you want.</li><li><code>first_kind</code> - A Bool. If true you get first kind polynomials. If false you get second kind.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of <code>UnivariateFunction</code>s for each polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/chebyshevs.jl#L22-L35">source</a></section></article><h3 id="Date-Conversions"><a class="docs-heading-anchor" href="#Date-Conversions">Date Conversions</a><a id="Date-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Date-Conversions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.years_between" href="#UnivariateFunctions.years_between"><code>UnivariateFunctions.years_between</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">years_between(a::Union{DateTime,Date}, b::Union{DateTime,Date})</code></pre><p>The number of years between two dates. This is returned as a scalar and assumes 365.2422 days per year.</p><p><strong>Inputs</strong></p><ul><li><code>a</code> - The end date</li><li><code>b</code> - The start date.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/date_conversions.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.years_from_global_base" href="#UnivariateFunctions.years_from_global_base"><code>UnivariateFunctions.years_from_global_base</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">years_from_global_base(a::Union{DateTime,Date})</code></pre><p>The number of years (calculated by the <code>years_between</code> function) between a given date and the 1st of January 2000.</p><p><strong>Inputs</strong></p><ul><li><code>date</code> - A date.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/date_conversions.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="UnivariateFunctions.period_length" href="#UnivariateFunctions.period_length"><code>UnivariateFunctions.period_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">period_length(a::Dates.DatePeriod, base::Date = global_base_date)</code></pre><p>Period length is designed to convert <code>TimePeriod</code> objects to a float in a consistent way to <code>years_from_global_base</code>. So effectively the years_between method is calculated with start and end dates being those at the start and end of a <code>Dates.DatePeriod</code>. This is slightly complicated because a period like <code>Month(3)</code> might have slightly different numbers of total days depending on when in the year it is. So a base date has to be input. The period is then measured starting from this base date.</p><p><strong>Inputs</strong></p><ul><li><code>period</code> - A period.</li><li><code>base</code> - A date from which the period will be measured from.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/28c801ecf30added48af0ea99f1d3f976797beb7/src/date_conversions.jl#L36-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Sunday 20 March 2022 23:49">Sunday 20 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
