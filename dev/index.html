<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · UnivariateFunctions</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>UnivariateFunctions</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Structs"><span>Structs</span></a></li><li><a class="tocitem" href="#Major-limitations"><span>Major limitations</span></a></li><li><a class="tocitem" href="#Interpolation-and-Splines"><span>Interpolation and Splines</span></a></li><li><a class="tocitem" href="#Approximation-and-regression"><span>Approximation and regression</span></a></li><li><a class="tocitem" href="#Date-Handling"><span>Date Handling</span></a></li><li class="toplevel"><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#For-basic-algebra:"><span>For basic algebra:</span></a></li><li><a class="tocitem" href="#For-data-interpolation"><span>For data interpolation</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h2><p>There are four main UnivariateFunction structs that are part of this package. These are:</p><ul><li>Undefined_Function - An undefined function behaves similarly to &quot;missing&quot; in Julia. Whenever anything is added/multiplied/etc with an undefined function the result is undefined. The integral and derivative of an undefined function is undefined. If an undefined function is evaluated it will return a missing.</li><li>PE<em>Function - This is the basic function type. It has a form of a \exp(b(x-base</em>)) (x-base)^d$.</li><li>Sum<em>Of</em>Functions - This is an array of PE<em>Functions. Note that by adding PE</em>Functions we can replicate any given polynomial. Hence from Weierstrass&#39; approximation theorem we can approximate any continuous function on a bounded domain to any desired level of accuracy (whether this is practical in numerical computing depends on the function being approximated).</li><li>Piecewise_Function - This defines a different UnivariateFunction for each part of the x domain.</li></ul><p>It is possible to perform any additions, subtractions, multiplications between any two UnivariateFunctions and between Ints/Floats and any UnivariateFunction. No division is allowed and it is not possible to raise a UnivariateFunction to a negative power. This is to ensure that all univariatefunctions are analytically integrable and differentiable. This may change in future releases.</p><h2 id="Major-limitations"><a class="docs-heading-anchor" href="#Major-limitations">Major limitations</a><a id="Major-limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Major-limitations" title="Permalink"></a></h2><ul><li>It is not possible to divide by univariate functions or raise them by a negative power.</li><li>When multiplying pe<em>functions with different base dates there is often an issue of very high or very low numbers that go outside machine precision. If one were trying to change a PE</em>Function from base 2010 to 50, this would not generally be possible. This is because to change <span>$a exp(x-2020)$</span> to <span>$q exp(x - 50)$</span> we need to premultiply the first expression by <span>$exp(-1950)$</span> which is a tiny number. In these cases it is better to do the algebra on paper and rewriting the code accordingly as often base changes cancel out on paper. It is also good to change bases as rarely as possible. If different univariate functions use different bases then there is a need to base change when multiplying them which can result in errors. Note that if base changes are segment in the x domain by means of a piecewise function then they should never interact meaning it is ok to use different bases here.</li><li>There is no support for finding optima, roots, fixedpoints etc. If anyone has an idea of how to do it efficiently then please let me know.</li><li>There is no support for finding a function representing the upper/lower envelope of multiple functions. If anyone has an idea of how to do it efficiently then please let me know.</li></ul><h2 id="Interpolation-and-Splines"><a class="docs-heading-anchor" href="#Interpolation-and-Splines">Interpolation and Splines</a><a id="Interpolation-and-Splines-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-and-Splines" title="Permalink"></a></h2><p>So far this package support the following interpolation schemes:</p><ul><li>Constant interpolation from the left to the right. Such a Piecewise<em>Function spline can be constructed by the create</em>constant<em>interpolation</em>to_right method.</li><li>Constant interpolation from the right to the left. Such a Piecewise<em>Function spline can be constructed by the create</em>constant<em>interpolation</em>to_left method.</li><li>Linear interpolation. Such a Piecewise<em>Function spline can be constructed by the create</em>linear_interpolation method.</li></ul><p>It also supports the following spline (which can also be used for interpolation)</p><ul><li>Schumaker shape preserving spline - Such a Piecewise<em>Function spline can be constructed by the create</em>quadratic_spline method.</li></ul><h2 id="Approximation-and-regression"><a class="docs-heading-anchor" href="#Approximation-and-regression">Approximation and regression</a><a id="Approximation-and-regression-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-and-regression" title="Permalink"></a></h2><p>So for this package supports the creation of the following approximation schemes:</p><ul><li>OLS regression. The create<em>ols</em>approximation function can create a UnivariateFunction approximating a linear relationship. The degree input to this function can be used to specify the number of higher powers of x to be used in approximating y. For instance if the degree is two then y will be approximated as a linear combination of x and x^2 as well as an intercept (if the intercept boolean is true).</li><li>Chebyshev polynomials - This will approximate a function using the Chebyshev basis functions. This approximation function can then be integrated to accomplish Chebyshev–Gauss quadrature.</li></ul><h2 id="Date-Handling"><a class="docs-heading-anchor" href="#Date-Handling">Date Handling</a><a id="Date-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Date-Handling" title="Permalink"></a></h2><ul><li>All base dates are immediately converted to floats and are not otherwise saved. Thus there is no difference between a PE<em>Function created with a base as a float and one created with the matching date. This is done to simplify the code. All date conversions is done by finding the year fractions between the date and the global base date of Date(2000,1,1). This particular global base date should not affect anything as long as it is consistent. It is relatively trivial to change it (in the date</em>conversions.jl file) and recompile however if desired.</li></ul><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="For-basic-algebra:"><a class="docs-heading-anchor" href="#For-basic-algebra:">For basic algebra:</a><a id="For-basic-algebra:-1"></a><a class="docs-heading-anchor-permalink" href="#For-basic-algebra:" title="Permalink"></a></h2><p>Consider we have a two functions f and g and want to add them, multiply them by some other function h, then square it and finally integrate the result between 2.0 and 2.8. This can be done analytically with UnivariateFunctions:</p><pre><code class="nohighlight hljs">f = PE_Function(1.0, 2.0, 4.0, 5)
g = PE_Function(1.3, 2.0, 4.3, 2)
h = PE_Function(5.0, 2.2, 1.0,0)
result_of_operations = (h*(f+g))^2
evaluate_integral(result_of_operations, 2.0, 2.8)</code></pre><h2 id="For-data-interpolation"><a class="docs-heading-anchor" href="#For-data-interpolation">For data interpolation</a><a id="For-data-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#For-data-interpolation" title="Permalink"></a></h2><p>Suppose we have want to approximate some function with some sampled points. First to generate some points</p><pre><code class="nohighlight hljs">using UnivariateFunctions
const global_base_date = Date(2000,1,1)
StartDate = Date(2018, 7, 21)
x = Array{Date}(undef, 1000)
for i in 1:1000
    x[i] = StartDate +Dates.Day(2* (i-1))
end
function ff(x::Date)
    days_between = years_from_global_base(x)
    return log(days_between) + sqrt(days_between)
end
y = ff.(x)</code></pre><p>Now we can generate a UnivariateFunction that can be used to easily interpolate from the sampled points:</p><pre><code class="nohighlight hljs">func = create_quadratic_spline(x,y)</code></pre><p>And we can evaluate from this function and integrate it and differentiate it in the normal way:</p><pre><code class="nohighlight hljs">evaluate(func, Date(2020,1,1))
evaluate.(Ref(func), [Date(2020,1,1), Date(2021,1,2)])
evaluate(derivative(func), Date(2021,1,2))
evaluate_integral(func, Date(2020,1,1), Date(2021,1,2))</code></pre><p>If we had wanted to interpolate instead with a constant method(from left or from right) or by linearly interpolating then we could have just generated func with a different method: create<em>constant</em>interpolation<em>to</em>left, create<em>constant</em>interpolation<em>to</em>right or create<em>linear</em>interpolation.</p><p>If we have lots of data that we want to summarise with OLS</p><pre><code class="nohighlight hljs"># Generating example data
using Random
Random.seed!(1)
obs = 1000
X = rand(obs)
y = X .+ rand(Normal(),obs) .+ 7
# And now making an approximation function
approxFunction = create_ols_approximation(y, X, 0.0, 2, true)</code></pre><p>And if we want to approximate the sin function in the [2.3, 5.6] bound with 7 polynomial terms and 20 approximation nodes:</p><pre><code class="nohighlight hljs">chebyshevs = create_chebyshev_approximation(sin, 20, 7, 2.3, 5.6)</code></pre><p>We can integrate the above term in the normal way to achieve Gauss-Chebyshev quadrature:</p><pre><code class="nohighlight hljs">evaluate_integral(chebyshevs, 2.3, 5.6)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Wednesday 22 September 2021 19:51">Wednesday 22 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
