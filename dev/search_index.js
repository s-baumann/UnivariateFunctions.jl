var documenterSearchIndex = {"docs":
[{"location":"api/#Internal-Functions","page":"API","title":"Internal Functions","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#Main-Structs","page":"API","title":"Main Structs","text":"","category":"section"},{"location":"api/#Function-Evaluation-and-Calculus","page":"API","title":"Function Evaluation and Calculus","text":"Note that in addition to the below functions the following operators:\n\n+, -, \\, *, ^\n\nhave also been overloaded so that a function will be returned with the analytical sum, difference, product, quotient, power. The restrictions are that you cannot divide by a function (although you can divide by a scalar) and only positive integer powers can be taken.","category":"section"},{"location":"api/#Interpolation","page":"API","title":"Interpolation","text":"","category":"section"},{"location":"api/#Approximation","page":"API","title":"Approximation","text":"","category":"section"},{"location":"api/#Smoothing","page":"API","title":"Smoothing","text":"","category":"section"},{"location":"api/#Monotonic-Regression","page":"API","title":"Monotonic Regression","text":"","category":"section"},{"location":"api/#Unimodal-Regression","page":"API","title":"Unimodal Regression","text":"","category":"section"},{"location":"api/#Cross-Validation-Model-Selection","page":"API","title":"Cross-Validation Model Selection","text":"","category":"section"},{"location":"api/#Internal-Functions-2","page":"API","title":"Internal Functions","text":"","category":"section"},{"location":"api/#Date-Conversions","page":"API","title":"Date Conversions","text":"","category":"section"},{"location":"api/#UnivariateFunctions.UnivariateFunction","page":"API","title":"UnivariateFunctions.UnivariateFunction","text":"UnivariateFunction\n\nAn abstract type. The concrete structs that have been implemented are UndefinedFunction,     PEFunction, SumOfFunctions, Piecewise_Function.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnivariateFunctions.Undefined_Function","page":"API","title":"UnivariateFunctions.Undefined_Function","text":"Undefined_Function <: UnivariateFunction\n\nThis function throws an error if you ever try to evaluate it. Think of it as doing the role of missing but for UnivariateFunctions\n\n\n\n\n\n","category":"type"},{"location":"api/#UnivariateFunctions.PE_Function","page":"API","title":"UnivariateFunctions.PE_Function","text":"PE_Function{F<:Real,I<:Integer} <: UnivariateFunction\n\nThis function has the functional form:     a exp(b(x-base)) (x-base)^d Where a,b,base are floats and d is a positive integer. These four are the  members of the struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnivariateFunctions.Sum_Of_Functions","page":"API","title":"UnivariateFunctions.Sum_Of_Functions","text":"Sum_Of_Functions <: UnivariateFunction\n\nThis function contants a vector of UnivariateFunctions. When evaluted it adds the evaluations of these functions and returns the sum.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnivariateFunctions.Piecewise_Function","page":"API","title":"UnivariateFunctions.Piecewise_Function","text":"Piecewise_Function <: UnivariateFunction\n\nThis function contants a vector of locations in the x space and a vector of UnivariateFunctions. When evaludated it uses these vectors as a lookup. It chooses the correct UnivariateFunction and evaluates it.\n\n\n\n\n\n","category":"type"},{"location":"api/#SchumakerSpline.evaluate","page":"API","title":"SchumakerSpline.evaluate","text":"evaluate(f::UnivariateFunction, r::Real)\nevaluate(f::UnivariateFunction, d::Q) where Q<:Union{Date,DateTime,ZonedDateTime}\nevaluate(f::UnivariateFunction, x::DatePeriod)\n\nThis evaluates the function at the requested point. If a Date, DateTime is input then it is first converted to a scalar with the years_from_global_base_date function. DatePeriods are converted with the period_length function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.derivative","page":"API","title":"UnivariateFunctions.derivative","text":"derivative(f::UnivariateFunction)\n\nThis calculates the derivative of the function and returns it as a UnivariateFunction.\n\nInputs\n\nf - A UnivariateFunction.\n\nReturns\n\nA UnivariateFunction.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.indefinite_integral","page":"API","title":"UnivariateFunctions.indefinite_integral","text":"indefinite_integral(f::UnivariateFunction)\n\nThis calculates the indefinite integral of a UnivariateFunction.\n\nInputs\n\nf - A UnivariateFunction.\n\nReturns\n\nA UnivariateFunction.\n\n\n\n\n\n","category":"function"},{"location":"api/#SchumakerSpline.evaluate_integral","page":"API","title":"SchumakerSpline.evaluate_integral","text":"evaluate_integral(f::UnivariateFunction,left::AbstractFloat, right::AbstractFloat)\nevaluate_integral(f::UnivariateFunction,left::Q, right::W) where Q<:Union{Date,DateTime,ZonedDateTime} where W<:Union{Date,DateTime,ZonedDateTime}\n\nThis calculates the integral of a function from a left limit to a right limit and returns a scalar.\n\nIf a Date, DateTime is input then it is first converted to a scalar with the zdt2unix function.\n\nInputs\n\nf - A UnivariateFunction.\nleft - A left limit (scalar)\nright - A right limit (scalar)\n\nReturns\n\nA Real.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.right_integral","page":"API","title":"UnivariateFunctions.right_integral","text":"right_integral(f::UnivariateFunction, left::Real)\nright_integral(f::UnivariateFunction, left::Q) where Q<:Union{Date,DateTime,ZonedDateTime}\n\nThis calculates the integral of a function from a left limit and returns it as a UnivariateFunction. So if you were to then evaluate this integral function at a point x then you would get the integral between left and x.\n\nIf a Date, DateTime is input then it is first converted to a scalar with the years_from_global_base_date function.\n\nInputs\n\nf - A UnivariateFunction.\nleft - A left limit (scalar)\n\nReturns\n\nA UnivariateFunction.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.left_integral","page":"API","title":"UnivariateFunctions.left_integral","text":"left_integral(f::UnivariateFunction, right::Real)\nleft_integral(f::UnivariateFunction, right::Q) where Q<:Union{Date,DateTime,ZonedDateTime}\n\nThis calculates the integral of a function from a right limit and returns it as a UnivariateFunction. So if you were to then evaluate this integral function at a point x then you would get the integral between right and x.\n\nIf a Date, DateTime is input then it is first converted to a scalar with the zdt2unix function.\n\nInputs\n\nf - A UnivariateFunction.\nright - A right limit (scalar)\n\nReturns\n\nA UnivariateFunction.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.create_quadratic_spline","page":"API","title":"UnivariateFunctions.create_quadratic_spline","text":"create_quadratic_spline(x::Vector{Q},y::Vector{<:Real} ; gradients::Union{Missing,Vector{<:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),\n                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing) where Q<:Union{Date,DateTime,ZonedDateTime}\ncreate_quadratic_spline(x::Vector{<:Real},y::Vector{<:Real} ; gradients::Union{Missing,Vector{<:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),\n                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing)\ncreate_quadratic_spline(x::Union{Vector{D},Vector{<:DatePeriod}},y::Vector{<:Real}; gradients::Union{Missing,Vector{<:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),\n                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing) where D<:DatePeriod\n\nMakes a quadratic shape-preserving interpolation spline using the SchumakerSpline.jl package. This is returned as a Piecewise_Function rather than as a Schumaker struct.\n\nInputs\n\nx - A Vector with the x coordinates\ny - A Vector with the y coordinates\ngradients - A Vector with the gradiants at each x location. This is calculated if not provided.\nextrapolation - A tuple of enum value describing how to extrapolate (on the left and right sides).\nleft_gradient - The gradiant to impose on the left edge (ie the first x coordinate).\nright_gradient - The gradiant to impose on the right edge (ie the last x coordinate).\n\nReturns\n\nA Piecewise_Function containing the spline.\n\ncreate_quadratic_spline(schum::Schumaker)\n\nThis converts a spline represented by a SchumakerSpline.Schumaker struct into the same spline but represented by a Piecewise_Function.\n\nInputs\n\nschum - A Schumaker struct.\n\nReturns\n\nA Piecewise_Function containing the spline.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.create_constant_interpolation_to_right","page":"API","title":"UnivariateFunctions.create_constant_interpolation_to_right","text":"create_constant_interpolation_to_right(x::Vector{Date},y::Vector{<:Real})\ncreate_constant_interpolation_to_right(x::Vector{<:Real},y::Vector{<:Real})\ncreate_constant_interpolation_to_right(x::Union{Vector{D},Vector{<:DatePeriod}},y::Vector{<:Real}) where D<:DatePeriod\n\nMakes a piecewise constant interpolation function. values from the left are copied to the right.\n\nInputs\n\nx - A Vector with the x coordinates\ny - A Vector with the y coordinates\n\nReturns\n\nA Piecewise_Function containing the interpolation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.create_constant_interpolation_to_left","page":"API","title":"UnivariateFunctions.create_constant_interpolation_to_left","text":"create_constant_interpolation_to_left(x::Vector{Date},y::Vector{<:Real})\ncreate_constant_interpolation_to_left(x::Vector{<:Real},y::Vector{<:Real})\ncreate_constant_interpolation_to_left(x::Union{Vector{D},Vector{<:DatePeriod}},y::Vector{<:Real}) where D<:DatePeriod\n\nMakes a piecewise constant interpolation function. values from the right are copied to the left.\n\nInputs\n\nx - A Vector with the x coordinates\ny - A Vector with the y coordinates\n\nReturns\n\nA Piecewise_Function containing the interpolation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.create_linear_interpolation","page":"API","title":"UnivariateFunctions.create_linear_interpolation","text":"create_linear_interpolation(x::Vector{Date},y::Vector{<:Real})\ncreate_linear_interpolation(x::Union{Vector{D},Vector{<:DatePeriod}},y::Vector{<:Real}) where D<:DatePeriod\ncreate_linear_interpolation(x::Vector{R},y::Vector{<:Real}) where R<:Real\n\nMakes a piecewise linear interpolation function. This is continuous.\n\nInputs\n\nx - A Vector with the x coordinates\ny - A Vector with the y coordinates\n\nReturns\n\nA Piecewise_Function containing the interpolation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.create_ols_approximation","page":"API","title":"UnivariateFunctions.create_ols_approximation","text":"create_ols_approximation(y::Vector{<:Real}, x::Vector{<:Real}, base_x::Real = 0.0, degree::Integer = 1, intercept::Bool = true)\ncreate_ols_approximation(y::Vector{<:Real}, x::Vector{Q}, base_x::Union{Date,DateTime} = global_base_date, degree::Integer = 1, intercept::Bool = true) where Q<:Union{Date,DateTime,ZonedDateTime}\n\nAn approximation function calculated via OLS.\n\nInputs\n\ny - A Vector with the y coordinates\nx - A Vector with the x coordinates\nbase_x - A real that offsets the x. So a coordinate with x value of 2.0 will be converted to 1.8 if base_x is 0.2.\ndegree - What the highest power of x should be. So if this is 3 then the equation will have x, x^2, x^3 as predictors.\nintercept - Should there be an x intercept.\n\nReturns\n\nA Sum_Of_Functions containing the approximation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.create_chebyshev_approximation","page":"API","title":"UnivariateFunctions.create_chebyshev_approximation","text":"create_chebyshev_approximation(func::Function, nodes::Integer, degree::Integer, left::Real, right::Real)\n\nAn function that will approximate another function via Chebyshev polynomials.\n\nInputs\n\nfunc - A function that you want to approximation\nnodes - The number of approximation nodes\ndegree - The degree of the Chebyshev polynomials.\nleft - The left limit of the approximation\nright - The right limit of the approximation.\n\nReturns\n\nA Sum_Of_Functions containing the approximation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.supersmoother","page":"API","title":"UnivariateFunctions.supersmoother","text":"supersmoother(x::Vector{R}, y::Vector{R}; \n              spans::Vector{R} = [0.05, 0.2, 0.5],\n              bass::R = 0.0) where R<:Real\n\nFriedman's SuperSmoother (1984) - a local linear regression with adaptive bandwidth.\n\nReturns a Piecewise_Function (linear interpolation of smoothed values).\n\nArguments\n\nx: Independent variable values\ny: Dependent variable values  \nspans: Candidate spans to consider (fraction of data points). Default [0.05, 0.2, 0.5]\nbass: Bass enhancement (0-10). Higher values favor smoother fits. Default 0.0\n\nExample\n\nf = supersmoother(x, y)\nf(2.5)  # evaluate at new point\nderivative(f)  # get derivative function\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.isotonic_regression","page":"API","title":"UnivariateFunctions.isotonic_regression","text":"isotonic_regression(x, y; increasing=true)\n\nFit an isotonic (monotonic step function) regression using the Pool Adjacent Violators (PAV) algorithm.\n\nArguments\n\nx: Independent variable values\ny: Dependent variable values\nincreasing: If true, fit monotonically increasing function; if false, decreasing. Default true\n\nReturns a Piecewise_Function representing the isotonic fit.\n\nExample\n\nx = collect(1.0:10.0)\ny = x .+ randn(10)\nfit = isotonic_regression(x, y; increasing=true)\nfit(5.5)  # evaluate at new point\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.monotonic_regression","page":"API","title":"UnivariateFunctions.monotonic_regression","text":"monotonic_regression(x, y; nbins=10, equally_spaced_bins=true, increasing=true)\n\nFit a piecewise linear monotonic regression using nonnegative least squares.\n\nThis method divides the x-domain into bins and fits a piecewise linear function with nonnegative slopes (for increasing) or nonpositive slopes (for decreasing).\n\nArguments\n\nx: Independent variable values\ny: Dependent variable values\nnbins: Number of bins for the piecewise linear fit. Default 10\nequally_spaced_bins: If true, bins are equally spaced in x; if false, based on observation quantiles. Default true\nincreasing: If true, fit monotonically increasing function; if false, decreasing. Default true\n\nReturns a Piecewise_Function representing the monotonic fit.\n\nExample\n\nx = collect(range(0, 5, length=100))\ny = sqrt.(x) .+ 0.1 .* randn(100)\nfit = monotonic_regression(x, y; nbins=15, increasing=true)\nfit(2.5)  # evaluate at new point\nderivative(fit)  # get derivative function\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.unimodal_regression","page":"API","title":"UnivariateFunctions.unimodal_regression","text":"unimodal_regression(x, y; nbins=10, equally_spaced_bins=true, convex=false, quasi=true)\n\nFit a unimodal regression function to the data.\n\nArguments\n\nx: Independent variable values\ny: Dependent variable values\nnbins: Number of bins for piecewise linear fit\nequally_spaced_bins: If true, bins are equally spaced; if false, based on observation quantiles\nconvex: If false, fits concave/quasiconcave (single maximum); if true, fits convex/quasiconvex (single minimum)\nquasi: If true, only enforces unimodality (slopes change sign once); if false, also enforces curvature\n\nShape constraints:\n\nconvex=false, quasi=true:  Quasiconcave - slopes go from + to - (single peak)\nconvex=true,  quasi=true:  Quasiconvex  - slopes go from - to + (single trough)\nconvex=false, quasi=false: Concave - slopes monotonically decrease\nconvex=true,  quasi=false: Convex  - slopes monotonically increase\n\nReturns a Piecewise_Function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.cv_monotonic_regression","page":"API","title":"UnivariateFunctions.cv_monotonic_regression","text":"cv_monotonic_regression(x, y; nbins=10, equally_spaced_bins=true, nfolds=10, seed=nothing)\n\nFit monotonic regression, automatically selecting increasing vs decreasing based on k-fold cross-validation error.\n\nReturns a CVRegressionResult containing:\n\nfitted: The fitted function (using full dataset)\nselected_shape: Either :increasing or :decreasing\ncv_errors: Dict mapping each shape to its CV error\nnfolds: Number of folds used\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.cv_unimodal_regression","page":"API","title":"UnivariateFunctions.cv_unimodal_regression","text":"cv_unimodal_regression(x, y; nbins=10, equally_spaced_bins=true, nfolds=10, seed=nothing)\n\nFit unimodal regression, automatically selecting among:\n\n:quasiconcave (convex=false, quasi=true)\n:quasiconvex  (convex=true,  quasi=true)\n:concave      (convex=false, quasi=false)\n:convex       (convex=true,  quasi=false)\n\nbased on k-fold cross-validation error.\n\nReturns a CVRegressionResult containing:\n\nfitted: The fitted function (using full dataset)\nselected_shape: One of the four shape symbols\ncv_errors: Dict mapping each shape to its CV error\nnfolds: Number of folds used\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.cv_shape_regression","page":"API","title":"UnivariateFunctions.cv_shape_regression","text":"cv_shape_regression(x, y; shapes=:all, nbins=10, equally_spaced_bins=true, nfolds=10, seed=nothing)\n\nFit regression with automatic shape selection via cross-validation.\n\nshapes can be:\n\n:monotonic - choose between increasing/decreasing\n:unimodal  - choose between quasiconcave/quasiconvex/concave/convex\n:all       - choose from all 6 shapes\nA vector of symbols, e.g. [:increasing, :quasiconcave, :convex]\n\nAvailable shapes: :increasing, :decreasing, :quasiconcave, :quasiconvex, :concave, :convex\n\nReturns a CVRegressionResult with the fitted function and selection metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.CVRegressionResult","page":"API","title":"UnivariateFunctions.CVRegressionResult","text":"CVRegressionResult{F<:UnivariateFunction}\n\nResult type for cross-validated regression model selection.\n\nFields\n\nfitted::F: The fitted UnivariateFunction (typically a Piecewise_Function)\nselected_shape::Symbol: The shape that was selected (e.g., :increasing, :quasiconcave)\ncv_errors::Dict{Symbol, Float64}: Cross-validation errors for each candidate shape\nnfolds::Int: Number of folds used in cross-validation\n\nThe result is callable - you can use it directly as a function:\n\nresult = cv_shape_regression(x, y)\nresult(2.5)  # equivalent to result.fitted(2.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#UnivariateFunctions.change_base_of_PE_Function","page":"API","title":"UnivariateFunctions.change_base_of_PE_Function","text":"change_base_of_PE_Function(f::PE_Function, new_base::Real)\n\nThis changes the base of a PE_Function. So if the base was 2 then it can be converted to 3 with an additional constant term.\n\nInputs\n\nf - A PE_Function.\nnew_base - The new base.\n\nReturns\n\nA PE_Function or a Sum_Of_Functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.trim_piecewise_function","page":"API","title":"UnivariateFunctions.trim_piecewise_function","text":"trim_piecewise_function(func::Piecewise_Function, left_limit::Real, right_limit::Real)\n\nThis trims the end of a piecewise function. So if there is a piecewise function with support between -10,10 then you can trim it to only have support between -5 and 5. Then if it is evaluated outside -5 to 5 it will be undefined.\n\nInputs\n\nfunc - A Piecewise_Function.\nleft_limit - The left limit.\nright_limit - The right limit.\n\nReturns\n\nA Piecewise_Function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.convert_to_linearly_rescale_inputs","page":"API","title":"UnivariateFunctions.convert_to_linearly_rescale_inputs","text":"convert_to_linearly_rescale_inputs(f::UnivariateFunction, alpha::Real, beta::Real)\n\nThis alters a function so that whenever we put in x it is like we put in alpha * x + beta.\n\nInputs\n\nf - A UnivariateFunction.\nalpha - The slope of the rescaling.\nbeta - The level of the rescaling.\n\nReturns\n\nA UnivariateFunction of the type that you input to the function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.get_chevyshevs_up_to","page":"API","title":"UnivariateFunctions.get_chevyshevs_up_to","text":"get_chevyshevs_up_to(N::Integer, first_kind::Bool = true)\n\nGet the first N chebyshev polynomials returned as a vector of UnivariateFunctions. The first 20 polynomials of each are precompiled into the binaries for speed. If you need more than that they will be calculated at runtime.\n\nThese can be from either the first kind or second kind polynomial sequence.\n\nInputs\n\nN - How many chebyshev polynomials do you want.\nfirst_kind - A Bool. If true you get first kind polynomials. If false you get second kind.\n\nReturns\n\nA Vector of UnivariateFunctions for each polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions._kfold_indices","page":"API","title":"UnivariateFunctions._kfold_indices","text":"_kfold_indices(n::Int, nfolds::Int; seed::Union{Int,Nothing}=nothing)\n\nGenerate random fold assignments for k-fold CV. Returns a vector of length n with values 1:nfolds.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions._cv_error","page":"API","title":"UnivariateFunctions._cv_error","text":"_cv_error(x, y, fold_indices, fit_func; kwargs...)\n\nCompute total cross-validation SSE for a given fitting function.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions._local_linear_smooth","page":"API","title":"UnivariateFunctions._local_linear_smooth","text":"_local_linear_smooth(x::Vector{R}, y::Vector{R}, span::R) where R<:Real\n\nCompute local linear regression smoothed values for all points. span is the fraction of data points to use in each local fit (0 < span ≤ 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions._local_linear_loo_residuals","page":"API","title":"UnivariateFunctions._local_linear_loo_residuals","text":"_local_linear_loo_residuals(x::Vector{R}, y::Vector{R}, span::R) where R<:Real\n\nCompute leave-one-out residuals for local linear regression at given span. Returns |yᵢ - ŷ₋ᵢ| for each point (prediction without using point i).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions._smooth_values","page":"API","title":"UnivariateFunctions._smooth_values","text":"_smooth_values(x::Vector{R}, v::Vector{R}, span::R) where R<:Real\n\nSmooth a vector v using local mean with given span. Used to smooth the span selection.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions._supersmoother_values","page":"API","title":"UnivariateFunctions._supersmoother_values","text":"_supersmoother_values(x::Vector{R}, y::Vector{R}; \n                      spans::Vector{R} = [0.05, 0.2, 0.5],\n                      bass::R = 0.0) where R<:Real\n\nCore SuperSmoother algorithm. Returns smoothed y values.\n\nspans: The three candidate spans to try (fraction of data)\nbass: Bass enhancement parameter (0-10). Higher values produce smoother results.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.seconds_between","page":"API","title":"UnivariateFunctions.seconds_between","text":"seconds_between(a::Union{ZonedDateTime,DateTime,Date}, b::Union{ZonedDateTime,DateTime,Date})\n\nThe number of seconds between two dates. This is the delta between two unixtimes.\n\nInputs\n\na - The end date\nb - The start date.\n\nReturns\n\nA Real.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.days_between","page":"API","title":"UnivariateFunctions.days_between","text":"days_between(a, b)\n\nThe number of days between two dates. Computed as seconds_between(a, b) / 86400.\n\nInputs\n\na - The end date (ZonedDateTime, DateTime, or Date)\nb - The start date (ZonedDateTime, DateTime, or Date)\n\nReturns\n\nA Real representing the number of days (can be fractional).\n\nExample\n\ndays_between(Date(2020, 1, 11), Date(2020, 1, 1))  # 10.0\ndays_between(DateTime(2020, 1, 1, 12, 0, 0), DateTime(2020, 1, 1, 0, 0, 0))  # 0.5\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.years_between","page":"API","title":"UnivariateFunctions.years_between","text":"years_between(a, b)\n\nThe number of years between two dates. Computed as seconds_between(a, b) / (365.25 * 86400).\n\nInputs\n\na - The end date (ZonedDateTime, DateTime, or Date)\nb - The start date (ZonedDateTime, DateTime, or Date)\n\nReturns\n\nA Real representing the number of years (can be fractional).\n\nExample\n\nyears_between(Date(2021, 1, 1), Date(2020, 1, 1))  # approximately 1.0\nyears_between(Date(2020, 7, 1), Date(2020, 1, 1))  # approximately 0.5\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.period_length","page":"API","title":"UnivariateFunctions.period_length","text":"period_length(a::Dates.DatePeriod, base::Date = global_base_date)\n\nPeriod length is designed to convert TimePeriod objects to a float in a consistent way to zdt2unix. So effectively the seconds_between method is calculated with start and end dates being those at the start and end of a Dates.DatePeriod. This is slightly complicated because a period like Month(3) might have slightly different numbers of total days depending on when in the year it is. So a base date has to be input. The period is then measured starting from this base date.\n\nInputs\n\nperiod - A period.\nbase - A date from which the period will be measured from.\n\nReturns\n\nA Real.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.years_from_global_base_date","page":"API","title":"UnivariateFunctions.years_from_global_base_date","text":"years_from_global_base_date(a)\n\nThe number of years between a date and the global base date (1970-01-01 00:00:00 UTC).\n\nThis is used internally to convert dates to floats for use in PE_Function bases.\n\nInputs\n\na - A ZonedDateTime, DateTime, or Date\n\nReturns\n\nA Real representing the number of years since 1970-01-01.\n\nExample\n\nyears_from_global_base_date(Date(1970, 1, 1))  # 0.0\nyears_from_global_base_date(Date(2020, 1, 1))  # approximately 50.0\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.zdt2unix","page":"API","title":"UnivariateFunctions.zdt2unix","text":"zdt2unix(d)\n\nConvert a ZonedDateTime, DateTime, or Date to Unix timestamp (seconds since 1970-01-01 00:00:00 UTC).\n\nInputs\n\nd - A ZonedDateTime, DateTime, Date, or missing\n\nReturns\n\nAn Int representing seconds since Unix epoch, or missing if input is missing.\n\nExample\n\nzdt2unix(Date(2020, 1, 1))  # 1577836800\nzdt2unix(DateTime(2020, 1, 1, 12, 0, 0))  # 1577880000\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.unix2zdt","page":"API","title":"UnivariateFunctions.unix2zdt","text":"unix2zdt(seconds_since_1970, tzz=tz\"UTC\")\n\nConvert Unix timestamp (seconds since 1970-01-01 00:00:00 UTC) to a ZonedDateTime.\n\nInputs\n\nseconds_since_1970 - Unix timestamp as Integer, Real, or missing\ntzz - Timezone (default: UTC)\n\nReturns\n\nA ZonedDateTime, or missing if input is missing.\n\nExample\n\nunix2zdt(1577836800)  # 2020-01-01T00:00:00+00:00\nunix2zdt(0, tz\"America/New_York\")  # 1969-12-31T19:00:00-05:00\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.unix2dt","page":"API","title":"UnivariateFunctions.unix2dt","text":"unix2dt(seconds_since_1970)\n\nConvert Unix timestamp (seconds since 1970-01-01 00:00:00 UTC) to a DateTime.\n\nInputs\n\nseconds_since_1970 - Unix timestamp as Integer, Real, or missing\n\nReturns\n\nA DateTime, or missing if input is missing.\n\nExample\n\nunix2dt(1577836800)  # 2020-01-01T00:00:00\n\n\n\n\n\n","category":"function"},{"location":"api/#UnivariateFunctions.unix2d","page":"API","title":"UnivariateFunctions.unix2d","text":"unix2d(seconds_since_1970)\n\nConvert Unix timestamp (seconds since 1970-01-01 00:00:00 UTC) to a Date.\n\nInputs\n\nseconds_since_1970 - Unix timestamp as Integer, Real, or missing\n\nReturns\n\nA Date, or missing if input is missing.\n\nExample\n\nunix2d(1577836800)  # 2020-01-01\n\n\n\n\n\n","category":"function"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/#For-basic-algebra:","page":"Examples","title":"For basic algebra:","text":"Consider we have a two functions f and g and want to add them, multiply them by some other function h, then square it and finally integrate the result between 2.0 and 2.8. This can be done analytically with UnivariateFunctions:\n\nf = PE_Function(1.0, 2.0, 4.0, 5)\ng = PE_Function(1.3, 2.0, 4.3, 2)\nh = PE_Function(5.0, 2.2, 1.0,0)\nresult_of_operations = (h*(f+g))^2\nevaluate_integral(result_of_operations, 2.0, 2.8)","category":"section"},{"location":"Examples/#For-data-interpolation","page":"Examples","title":"For data interpolation","text":"Suppose we have want to approximate some function with some sampled points. First to generate some points\n\nusing UnivariateFunctions\nconst global_base_date = Date(2000,1,1)\nStartDate = Date(2018, 7, 21)\nx = Array{Date}(undef, 1000)\nfor i in 1:1000\n    x[i] = StartDate +Dates.Day(2* (i-1))\nend\nfunction ff(x::Date)\n    days_between = zdt2unix(x)\n    return log(days_between) + sqrt(days_between)\nend\ny = ff.(x)\n\nNow we can generate a UnivariateFunction that can be used to easily interpolate from the sampled points:\n\nfunc = create_quadratic_spline(x,y)\n\nAnd we can evaluate from this function and integrate it and differentiate it in the normal way:\n\nevaluate(func, Date(2020,1,1))\nevaluate.(Ref(func), [Date(2020,1,1), Date(2021,1,2)])\nevaluate(derivative(func), Date(2021,1,2))\nevaluate_integral(func, Date(2020,1,1), Date(2021,1,2))\n\nIf we had wanted to interpolate instead with a constant method (from left or from right) or by linearly interpolating then we could have just generated func with a different method:\n\ncreate_constant_interpolation_to_left,\ncreate_constant_interpolation_to_right,\ncreate_linear_interpolation.","category":"section"},{"location":"Examples/#For-approximation-fitting-a-UnivariateFunction-to-data","page":"Examples","title":"For approximation - fitting a UnivariateFunction to data","text":"If we have lots of data that we want to summarise with OLS\n\n# Generating example data\nusing Random\nRandom.seed!(1)\nobs = 1000\nX = rand(obs)\ny = X .+ rand(Normal(),obs) .+ 7\n# And now making an approximation function\napproxFunction = create_ols_approximation(y, X, 0.0, 2, true)","category":"section"},{"location":"Examples/#For-approximation-fitting-a-UnivariateFunction-to-a-function-with-Chebyshev-Polynomials","page":"Examples","title":"For approximation - fitting a UnivariateFunction to a function with Chebyshev Polynomials","text":"And if we want to approximate the sin function in the [2.3, 5.6] bound with 7 polynomial terms and 20 approximation nodes:\n\nchebyshevs = create_chebyshev_approximation(sin, 20, 7, 2.3, 5.6)\n\nWe can integrate the above term in the normal way to achieve Gauss-Chebyshev quadrature:\n\nevaluate_integral(chebyshevs, 2.3, 5.6)","category":"section"},{"location":"Regression/#Regression-and-Smoothing","page":"Regression and Smoothing","title":"Regression and Smoothing","text":"This package provides several regression and smoothing methods that fit Piecewise_Function objects to data. Because the fitted functions are UnivariateFunctions, you can differentiate, integrate, and combine them analytically.","category":"section"},{"location":"Regression/#Overview-of-Methods","page":"Regression and Smoothing","title":"Overview of Methods","text":"Function Description Shape Constraint\nsupersmoother Adaptive local linear regression None (flexible)\nisotonic_regression Pool Adjacent Violators algorithm Monotonic\nmonotonic_regression Binned monotonic regression Monotonic (piecewise linear)\nunimodal_regression Single peak/trough regression Unimodal or curvature-constrained\ncv_monotonic_regression Auto-select increasing/decreasing Monotonic with CV\ncv_unimodal_regression Auto-select unimodal shape Unimodal with CV\ncv_shape_regression Auto-select from all shapes Any shape with CV","category":"section"},{"location":"Regression/#SuperSmoother","page":"Regression and Smoothing","title":"SuperSmoother","text":"Friedman's SuperSmoother (1984) is a local linear regression with adaptive bandwidth selection. It automatically chooses the amount of smoothing at each point based on the local structure of the data.\n\nusing UnivariateFunctions\nusing Random, Distributions\n\n# Generate noisy sinusoidal data\nRandom.seed!(42)\nx = collect(range(0, 4π, length=200))\ny = sin.(x) .+ rand(Normal(0, 0.3), 200)\n\n# Fit supersmoother\nfit = supersmoother(x, y)\n\n# Evaluate at new points\nfit(2.5)\nfit.(collect(0:0.1:4π))\n\n# Get derivative and integral\nderiv = derivative(fit)\ninteg = indefinite_integral(fit)","category":"section"},{"location":"Regression/#Parameters","page":"Regression and Smoothing","title":"Parameters","text":"spans: Vector of candidate spans (fraction of data). Default [0.05, 0.2, 0.5]\nbass: Bass enhancement (0-10). Higher values favor smoother fits. Default 0.0\n\n# More smoothing with bass enhancement\nfit_smooth = supersmoother(x, y; bass=8.0)\n\n# Less smoothing with smaller spans\nfit_rough = supersmoother(x, y; spans=[0.02, 0.05, 0.1])","category":"section"},{"location":"Regression/#Isotonic-Regression","page":"Regression and Smoothing","title":"Isotonic Regression","text":"Isotonic regression fits a monotonically increasing (or decreasing) step function using the Pool Adjacent Violators (PAV) algorithm. This is useful when you know the relationship should be monotonic but don't want to assume a parametric form.\n\n# Generate increasing data with noise\nx = collect(range(0, 5, length=100))\ny = 2.0 .* x .+ rand(Normal(0, 1.0), 100)\n\n# Fit isotonic increasing\nfit_inc = isotonic_regression(x, y; increasing=true)\n\n# Fit isotonic decreasing\nfit_dec = isotonic_regression(x, y; increasing=false)","category":"section"},{"location":"Regression/#Monotonic-Regression","page":"Regression and Smoothing","title":"Monotonic Regression","text":"monotonic_regression fits a piecewise linear function with monotonicity constraints using nonnegative least squares. This gives smoother results than isotonic_regression while still enforcing monotonicity.\n\n# Fit with 15 bins, equally spaced\nfit = monotonic_regression(x, y; nbins=15, increasing=true)\n\n# Use observation-based bins (quantile spacing)\nfit_quantile = monotonic_regression(x, y; nbins=15, equally_spaced_bins=false)","category":"section"},{"location":"Regression/#Parameters-2","page":"Regression and Smoothing","title":"Parameters","text":"nbins: Number of bins for piecewise linear fit. Default 10\nequally_spaced_bins: If true, bins are equally spaced in x; if false, based on observation quantiles. Default true\nincreasing: If true, fit increasing function; if false, decreasing. Default true","category":"section"},{"location":"Regression/#Unimodal-Regression","page":"Regression and Smoothing","title":"Unimodal Regression","text":"unimodal_regression fits functions with a single peak (concave/quasiconcave) or single trough (convex/quasiconvex). This is useful for data with a clear maximum or minimum.","category":"section"},{"location":"Regression/#Shape-Options","page":"Regression and Smoothing","title":"Shape Options","text":"The function supports four shape constraints controlled by convex and quasi parameters:\n\nconvex quasi Shape Description\nfalse true Quasiconcave Single peak: slopes go + then -\ntrue true Quasiconvex Single trough: slopes go - then +\nfalse false Concave Slopes monotonically decrease\ntrue false Convex Slopes monotonically increase\n\n# Data with a single peak\nx = collect(range(-3, 3, length=200))\ny = -2 .* (x .- 0.5).^2 .+ 5 .+ rand(Normal(0, 0.4), 200)\n\n# Fit quasiconcave (single peak, no curvature constraint)\nfit_qc = unimodal_regression(x, y; convex=false, quasi=true)\n\n# Fit true concave (slopes must decrease)\nfit_c = unimodal_regression(x, y; convex=false, quasi=false)\n\n# Data with a single trough\ny_trough = 2 .* (x .- 0.5).^2 .+ 1 .+ rand(Normal(0, 0.4), 200)\n\n# Fit quasiconvex (single trough)\nfit_qv = unimodal_regression(x, y_trough; convex=true, quasi=true)\n\n# Fit true convex (slopes must increase)\nfit_v = unimodal_regression(x, y_trough; convex=true, quasi=false)","category":"section"},{"location":"Regression/#Parameters-3","page":"Regression and Smoothing","title":"Parameters","text":"nbins: Number of bins for piecewise linear fit. Default 10\nequally_spaced_bins: If true, bins are equally spaced; if false, quantile-based. Default true\nconvex: If false, fit peak (concave); if true, fit trough (convex). Default false\nquasi: If true, only enforce unimodality; if false, also enforce curvature. Default true","category":"section"},{"location":"Regression/#Cross-Validation-Model-Selection","page":"Regression and Smoothing","title":"Cross-Validation Model Selection","text":"When you're unsure about the shape of the relationship, use cross-validation to automatically select the best shape.","category":"section"},{"location":"Regression/#cv*monotonic*regression","page":"Regression and Smoothing","title":"cvmonotonicregression","text":"Automatically selects between increasing and decreasing monotonic functions:\n\n# Let CV decide if relationship is increasing or decreasing\nresult = cv_monotonic_regression(x, y; nbins=15, nfolds=10, seed=42)\n\n# Access the fitted function\nresult.fitted(2.5)\n\n# See which shape was selected\nresult.selected_shape  # :increasing or :decreasing\n\n# Compare CV errors\nresult.cv_errors  # Dict(:increasing => ..., :decreasing => ...)","category":"section"},{"location":"Regression/#cv*unimodal*regression","page":"Regression and Smoothing","title":"cvunimodalregression","text":"Automatically selects among the four unimodal shapes:\n\nresult = cv_unimodal_regression(x, y; nbins=12, nfolds=10, seed=42)\n\nresult.selected_shape  # :quasiconcave, :quasiconvex, :concave, or :convex\nresult.cv_errors       # Dict with all four CV errors","category":"section"},{"location":"Regression/#cv*shape*regression","page":"Regression and Smoothing","title":"cvshaperegression","text":"The most flexible option - selects from all six shapes (2 monotonic + 4 unimodal):\n\n# Choose from all shapes\nresult = cv_shape_regression(x, y; shapes=:all, nbins=12, nfolds=10, seed=42)\n\n# Or restrict to specific categories\nresult_mono = cv_shape_regression(x, y; shapes=:monotonic)  # increasing/decreasing only\nresult_uni = cv_shape_regression(x, y; shapes=:unimodal)    # unimodal shapes only\n\n# Or specify exactly which shapes to consider\nresult_custom = cv_shape_regression(x, y; shapes=[:increasing, :quasiconcave, :convex])","category":"section"},{"location":"Regression/#CVRegressionResult","page":"Regression and Smoothing","title":"CVRegressionResult","text":"All CV functions return a CVRegressionResult struct:\n\nstruct CVRegressionResult\n    fitted::Piecewise_Function  # The fitted function\n    selected_shape::Symbol       # Which shape was selected\n    cv_errors::Dict{Symbol, Float64}  # CV error for each candidate\n    nfolds::Int                  # Number of folds used\nend\n\nThe result is callable - you can use it directly as a function:\n\nresult = cv_shape_regression(x, y)\nresult(2.5)  # Evaluates the fitted function at 2.5","category":"section"},{"location":"Regression/#DataFrame-Interface","page":"Regression and Smoothing","title":"DataFrame Interface","text":"All regression functions support a DataFrame interface:\n\nusing DataFrames\n\ndf = DataFrame(x = x, y = y)\n\n# All functions accept DataFrame + column symbols\nfit = supersmoother(df, :x, :y)\nfit = monotonic_regression(df, :x, :y; increasing=true)\nfit = unimodal_regression(df, :x, :y; convex=false)\nfit = cv_shape_regression(df, :x, :y; shapes=:all)","category":"section"},{"location":"Regression/#Working-with-Fitted-Functions","page":"Regression and Smoothing","title":"Working with Fitted Functions","text":"Since all fitted functions are Piecewise_Functions (which are UnivariateFunctions), you get full access to analytical operations:\n\nfit = supersmoother(x, y)\n\n# Derivative - returns another Piecewise_Function\nderiv = derivative(fit)\nderiv(2.5)  # Evaluate derivative at a point\n\n# Indefinite integral\ninteg = indefinite_integral(fit)\n\n# Definite integral\narea = evaluate_integral(fit, 0.0, 5.0)\n\n# Combine with other functions\ng = PE_Function(2.0, 0.0, 0.0, 1)  # g(x) = 2x\ncombined = fit + g\ncombined = fit * g\ncombined = fit^2\n\n# Plot (requires VegaLite)\nplot(fit, 0.0, 5.0)","category":"section"},{"location":"Regression/#Complete-Example","page":"Regression and Smoothing","title":"Complete Example","text":"using UnivariateFunctions\nusing DataFrames, Random, Distributions\n\nRandom.seed!(123)\n\n# Generate data with unknown shape\nn = 200\nx = collect(range(0, 6, length=n))\ny = 3 .* sin.(x) .+ 0.3 .* x .+ rand(Normal(0, 0.5), n)\n\ndf = DataFrame(x = x, y = y)\n\n# Use CV to find the best shape\nresult = cv_shape_regression(x, y; shapes=:all, nbins=15, nfolds=10, seed=42)\n\nprintln(\"Selected shape: \", result.selected_shape)\nprintln(\"CV errors:\")\nfor (shape, err) in sort(collect(result.cv_errors), by=x->x[2])\n    println(\"  $shape: $(round(err, digits=2))\")\nend\n\n# Use the fitted function\nfit = result.fitted\n\n# Compute derivative to find rate of change\nderiv = derivative(fit)\n\n# Find total area under curve\narea = evaluate_integral(fit, 0.0, 6.0)\nprintln(\"Area under curve: \", round(area, digits=4))\n\n# Plot fit over data\nplt = plot(fit, df; x_name=:x, y_name=:y)","category":"section"},{"location":"#Structs","page":"Overview","title":"Structs","text":"There are four main UnivariateFunction structs that are part of this package. These are:\n\nUndefined_Function - An undefined function behaves similarly to \"missing\" in Julia. Whenever anything is added/multiplied/etc with an undefined function the result is undefined. The integral and derivative of an undefined function is undefined. If an undefined function is evaluated it will return a missing.\nPE_Function - This is the basic function type. It has a form of\n\na exp(b(x-base_)) (x-base)^d\n\nSum_Of_Functions - This is an array of PE_Functions. Note that by adding PE_Functions we can replicate any given polynomial. Hence from Weierstrass' approximation theorem we can approximate any continuous function on a bounded domain to any desired level of accuracy (whether this is practical in numerical computing depends on the function being approximated).\nPiecewise_Function - This defines a different UnivariateFunction for each part of the x domain.\n\nIt is possible to perform any additions, subtractions, multiplications between any two UnivariateFunctions and between Ints/Floats and any UnivariateFunction. No division is allowed and it is not possible to raise a UnivariateFunction to a negative power. This is to ensure that all Univariatefunctions are analytically integrable and differentiable. This may change in future releases.","category":"section"},{"location":"#Interpolation-and-Splines","page":"Overview","title":"Interpolation and Splines","text":"So far this package support the following interpolation schemes:\n\nConstant interpolation from the left to the right. Such a Piecewise_Function spline can be constructed by the create_constant_interpolation_to_right method.\nConstant interpolation from the right to the left. Such a Piecewise_Function spline can be constructed by the create_constant_interpolation_to_left method.\nLinear interpolation. Such a Piecewise_Function spline can be constructed by the create_linear_interpolation method.\n\nIt also supports the following spline (which can also be used for interpolation)\n\nSchumaker shape preserving spline - Such a Piecewise_Function spline can be constructed by the create_quadratic_spline method.","category":"section"},{"location":"#Approximation-and-regression","page":"Overview","title":"Approximation and regression","text":"This package supports the creation of the following approximation and regression schemes:\n\nOLS regression. The create_ols_approximation function can create a UnivariateFunction approximating a linear relationship. The degree input to this function can be used to specify the number of higher powers of x to be used in approximating y. For instance if the degree is two then y will be approximated as a linear combination of x and x^2 as well as an intercept (if the intercept boolean is true).\nChebyshev polynomials - This will approximate a function using the Chebyshev basis functions. This approximation function can then be integrated to accomplish Chebyshev–Gauss quadrature.","category":"section"},{"location":"#Regression-and-Smoothing","page":"Overview","title":"Regression and Smoothing","text":"The package provides several shape-constrained regression methods that return Piecewise_Function objects:\n\nsupersmoother - Friedman's SuperSmoother (1984), an adaptive local linear regression that automatically selects bandwidth at each point.\nisotonic_regression - Fits a monotonic step function using the Pool Adjacent Violators algorithm.\nmonotonic_regression - Fits a piecewise linear monotonic function using nonnegative least squares.\nunimodal_regression - Fits functions with a single peak (quasiconcave/concave) or trough (quasiconvex/convex).\n\nCross-validation functions are also provided for automatic shape selection:\n\ncv_monotonic_regression - Automatically selects between increasing and decreasing.\ncv_unimodal_regression - Automatically selects among the four unimodal shapes.\ncv_shape_regression - Selects from all six shapes (monotonic + unimodal) or a custom subset.\n\nSee the Regression and Smoothing page for detailed documentation and examples.","category":"section"},{"location":"#Date-Handling","page":"Overview","title":"Date Handling","text":"All base dates are immediately converted to floats and are not otherwise saved. Thus there is no difference between a PE_Function created with a base as a float and one created with the matching date. This is done to simplify the code. All date conversions is done by finding the year fractions between the date and the global base date of Date(2000,1,1). This particular global base date should not affect anything as long as it is consistent. It is relatively trivial to change it (in the date_conversions.jl file) and recompile however if desired.","category":"section"},{"location":"#Major-limitations","page":"Overview","title":"Major limitations","text":"It is not possible to divide by univariate functions or raise them by a negative power.\nWhen multiplying PE_Functions with different base dates there is often an issue of very high or very low numbers that go outside machine precision. If one were trying to change a PE_Function from base 2010 to 50, this would not generally be possible. This is because to change a exp(x-2020) to q exp(x - 50) we need to premultiply the first expression by exp(-1950) which is a tiny number. In these cases it is better to do the algebra on paper and rewriting the code accordingly as often base changes cancel out on paper. It is also good to change bases as rarely as possible. If different univariate functions use different bases then there is a need to base change when multiplying them which can result in errors. Note that if base changes are segment in the x domain by means of a piecewise function then they should never interact meaning it is ok to use different bases here.\nThere is no support for finding optima, roots, fixedpoints etc. If anyone has an idea of how to do it efficiently then please let me know.\nThere is no support for finding a function representing the upper/lower envelope of multiple functions. If anyone has an idea of how to do it efficiently then please let me know.","category":"section"}]
}
