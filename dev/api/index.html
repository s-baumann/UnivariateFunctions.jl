<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · UnivariateFunctions</title><meta name="title" content="API · UnivariateFunctions"/><meta property="og:title" content="API · UnivariateFunctions"/><meta property="twitter:title" content="API · UnivariateFunctions"/><meta name="description" content="Documentation for UnivariateFunctions."/><meta property="og:description" content="Documentation for UnivariateFunctions."/><meta property="twitter:description" content="Documentation for UnivariateFunctions."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">UnivariateFunctions</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../Regression/">Regression and Smoothing</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/s-baumann/UnivariateFunctions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><ul><li><a href="#UnivariateFunctions.CVRegressionResult"><code>UnivariateFunctions.CVRegressionResult</code></a></li><li><a href="#UnivariateFunctions.PE_Function"><code>UnivariateFunctions.PE_Function</code></a></li><li><a href="#UnivariateFunctions.Piecewise_Function"><code>UnivariateFunctions.Piecewise_Function</code></a></li><li><a href="#UnivariateFunctions.Sum_Of_Functions"><code>UnivariateFunctions.Sum_Of_Functions</code></a></li><li><a href="#UnivariateFunctions.Undefined_Function"><code>UnivariateFunctions.Undefined_Function</code></a></li><li><a href="#UnivariateFunctions.UnivariateFitter"><code>UnivariateFunctions.UnivariateFitter</code></a></li><li><a href="#UnivariateFunctions.UnivariateFunction"><code>UnivariateFunctions.UnivariateFunction</code></a></li><li><a href="#SchumakerSpline.evaluate"><code>SchumakerSpline.evaluate</code></a></li><li><a href="#SchumakerSpline.evaluate_integral"><code>SchumakerSpline.evaluate_integral</code></a></li><li><a href="#UnivariateFunctions._cv_error"><code>UnivariateFunctions._cv_error</code></a></li><li><a href="#UnivariateFunctions._kfold_indices"><code>UnivariateFunctions._kfold_indices</code></a></li><li><a href="#UnivariateFunctions._local_linear_loo_residuals"><code>UnivariateFunctions._local_linear_loo_residuals</code></a></li><li><a href="#UnivariateFunctions._local_linear_smooth"><code>UnivariateFunctions._local_linear_smooth</code></a></li><li><a href="#UnivariateFunctions._smooth_values"><code>UnivariateFunctions._smooth_values</code></a></li><li><a href="#UnivariateFunctions._supersmoother_values"><code>UnivariateFunctions._supersmoother_values</code></a></li><li><a href="#UnivariateFunctions.change_base_of_PE_Function"><code>UnivariateFunctions.change_base_of_PE_Function</code></a></li><li><a href="#UnivariateFunctions.convert_to_linearly_rescale_inputs"><code>UnivariateFunctions.convert_to_linearly_rescale_inputs</code></a></li><li><a href="#UnivariateFunctions.create_chebyshev_approximation"><code>UnivariateFunctions.create_chebyshev_approximation</code></a></li><li><a href="#UnivariateFunctions.create_constant_interpolation_to_left"><code>UnivariateFunctions.create_constant_interpolation_to_left</code></a></li><li><a href="#UnivariateFunctions.create_constant_interpolation_to_right"><code>UnivariateFunctions.create_constant_interpolation_to_right</code></a></li><li><a href="#UnivariateFunctions.create_linear_interpolation"><code>UnivariateFunctions.create_linear_interpolation</code></a></li><li><a href="#UnivariateFunctions.create_ols_approximation"><code>UnivariateFunctions.create_ols_approximation</code></a></li><li><a href="#UnivariateFunctions.create_quadratic_spline"><code>UnivariateFunctions.create_quadratic_spline</code></a></li><li><a href="#UnivariateFunctions.cv_monotonic_regression"><code>UnivariateFunctions.cv_monotonic_regression</code></a></li><li><a href="#UnivariateFunctions.cv_shape_regression"><code>UnivariateFunctions.cv_shape_regression</code></a></li><li><a href="#UnivariateFunctions.cv_unimodal_regression"><code>UnivariateFunctions.cv_unimodal_regression</code></a></li><li><a href="#UnivariateFunctions.days_between"><code>UnivariateFunctions.days_between</code></a></li><li><a href="#UnivariateFunctions.derivative"><code>UnivariateFunctions.derivative</code></a></li><li><a href="#UnivariateFunctions.fit!"><code>UnivariateFunctions.fit!</code></a></li><li><a href="#UnivariateFunctions.get_chevyshevs_up_to"><code>UnivariateFunctions.get_chevyshevs_up_to</code></a></li><li><a href="#UnivariateFunctions.indefinite_integral"><code>UnivariateFunctions.indefinite_integral</code></a></li><li><a href="#UnivariateFunctions.isotonic_regression"><code>UnivariateFunctions.isotonic_regression</code></a></li><li><a href="#UnivariateFunctions.left_integral"><code>UnivariateFunctions.left_integral</code></a></li><li><a href="#UnivariateFunctions.monotonic_regression"><code>UnivariateFunctions.monotonic_regression</code></a></li><li><a href="#UnivariateFunctions.period_length"><code>UnivariateFunctions.period_length</code></a></li><li><a href="#UnivariateFunctions.right_integral"><code>UnivariateFunctions.right_integral</code></a></li><li><a href="#UnivariateFunctions.seconds_between"><code>UnivariateFunctions.seconds_between</code></a></li><li><a href="#UnivariateFunctions.simplify"><code>UnivariateFunctions.simplify</code></a></li><li><a href="#UnivariateFunctions.supersmoother"><code>UnivariateFunctions.supersmoother</code></a></li><li><a href="#UnivariateFunctions.trim_piecewise_function"><code>UnivariateFunctions.trim_piecewise_function</code></a></li><li><a href="#UnivariateFunctions.unimodal_regression"><code>UnivariateFunctions.unimodal_regression</code></a></li><li><a href="#UnivariateFunctions.unix2d"><code>UnivariateFunctions.unix2d</code></a></li><li><a href="#UnivariateFunctions.unix2dt"><code>UnivariateFunctions.unix2dt</code></a></li><li><a href="#UnivariateFunctions.unix2zdt"><code>UnivariateFunctions.unix2zdt</code></a></li><li><a href="#UnivariateFunctions.years_between"><code>UnivariateFunctions.years_between</code></a></li><li><a href="#UnivariateFunctions.years_from_global_base_date"><code>UnivariateFunctions.years_from_global_base_date</code></a></li><li><a href="#UnivariateFunctions.zdt2unix"><code>UnivariateFunctions.zdt2unix</code></a></li></ul><h3 id="Main-Structs"><a class="docs-heading-anchor" href="#Main-Structs">Main Structs</a><a id="Main-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Structs" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.UnivariateFunction"><a class="docstring-binding" href="#UnivariateFunctions.UnivariateFunction"><code>UnivariateFunctions.UnivariateFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnivariateFunction</code></pre><p>An abstract type. The concrete structs that have been implemented are Undefined<em>Function,     PE</em>Function, Sum<em>Of</em>Functions, Piecewise_Function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.Undefined_Function"><a class="docstring-binding" href="#UnivariateFunctions.Undefined_Function"><code>UnivariateFunctions.Undefined_Function</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Undefined_Function &lt;: UnivariateFunction</code></pre><p>This function throws an error if you ever try to evaluate it. Think of it as doing the role of missing but for UnivariateFunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.PE_Function"><a class="docstring-binding" href="#UnivariateFunctions.PE_Function"><code>UnivariateFunctions.PE_Function</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PE_Function{F&lt;:Real,I&lt;:Integer} &lt;: UnivariateFunction</code></pre><p>This function has the functional form:     a exp(b(x-base)) (x-base)^d Where a,b,base are floats and d is a positive integer. These four are the  members of the struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L21-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.Sum_Of_Functions"><a class="docstring-binding" href="#UnivariateFunctions.Sum_Of_Functions"><code>UnivariateFunctions.Sum_Of_Functions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Sum_Of_Functions &lt;: UnivariateFunction</code></pre><p>This function contants a vector of UnivariateFunctions. When evaluted it adds the evaluations of these functions and returns the sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L62-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.Piecewise_Function"><a class="docstring-binding" href="#UnivariateFunctions.Piecewise_Function"><code>UnivariateFunctions.Piecewise_Function</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Piecewise_Function &lt;: UnivariateFunction</code></pre><p>This function contants a vector of locations in the x space and a vector of UnivariateFunctions. When evaludated it uses these vectors as a lookup. It chooses the correct UnivariateFunction and evaluates it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L84-L90">source</a></section></details></article><h3 id="Function-Evaluation-and-Calculus"><a class="docs-heading-anchor" href="#Function-Evaluation-and-Calculus">Function Evaluation and Calculus</a><a id="Function-Evaluation-and-Calculus-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Evaluation-and-Calculus" title="Permalink"></a></h3><p>Note that in addition to the below functions the following operators:</p><p><code>+</code>, <code>-</code>, <code>\</code>, <code>*</code>, <code>^</code></p><p>have also been overloaded so that a function will be returned with the analytical sum, difference, product, quotient, power. The restrictions are that you cannot divide by a function (although you can divide by a scalar) and only positive integer powers can be taken.</p><article><details class="docstring" open="true"><summary id="SchumakerSpline.evaluate"><a class="docstring-binding" href="#SchumakerSpline.evaluate"><code>SchumakerSpline.evaluate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate(f::UnivariateFunction, r::Real)
evaluate(f::UnivariateFunction, d::Q) where Q&lt;:Union{Date,DateTime,ZonedDateTime}
evaluate(f::UnivariateFunction, x::DatePeriod)</code></pre><p>This evaluates the function at the requested point. If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>years_from_global_base_date</code> function. <code>DatePeriod</code>s are converted with the <code>period_length</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L274-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.derivative"><a class="docstring-binding" href="#UnivariateFunctions.derivative"><code>UnivariateFunctions.derivative</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">derivative(f::UnivariateFunction)</code></pre><p>This calculates the derivative of the function and returns it as a <code>UnivariateFunction</code>.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/1_undefined_function.jl#L10-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.indefinite_integral"><a class="docstring-binding" href="#UnivariateFunctions.indefinite_integral"><code>UnivariateFunctions.indefinite_integral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">indefinite_integral(f::UnivariateFunction)</code></pre><p>This calculates the indefinite integral of a <code>UnivariateFunction</code>.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/1_undefined_function.jl#L23-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SchumakerSpline.evaluate_integral"><a class="docstring-binding" href="#SchumakerSpline.evaluate_integral"><code>SchumakerSpline.evaluate_integral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate_integral(f::UnivariateFunction,left::AbstractFloat, right::AbstractFloat)
evaluate_integral(f::UnivariateFunction,left::Q, right::W) where Q&lt;:Union{Date,DateTime,ZonedDateTime} where W&lt;:Union{Date,DateTime,ZonedDateTime}</code></pre><p>This calculates the integral of a function from a left limit to a right limit and returns a scalar.</p><p>If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>zdt2unix</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>left</code> - A left limit (scalar)</li><li><code>right</code> - A right limit (scalar)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/5_calculus.jl#L120-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.right_integral"><a class="docstring-binding" href="#UnivariateFunctions.right_integral"><code>UnivariateFunctions.right_integral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_integral(f::UnivariateFunction, left::Real)
right_integral(f::UnivariateFunction, left::Q) where Q&lt;:Union{Date,DateTime,ZonedDateTime}</code></pre><p>This calculates the integral of a function from a left limit and returns it as a UnivariateFunction. So if you were to then evaluate this integral function at a point x then you would get the integral between left and x.</p><p>If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>years_from_global_base_date</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>left</code> - A left limit (scalar)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/5_calculus.jl#L4-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.left_integral"><a class="docstring-binding" href="#UnivariateFunctions.left_integral"><code>UnivariateFunctions.left_integral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_integral(f::UnivariateFunction, right::Real)
left_integral(f::UnivariateFunction, right::Q) where Q&lt;:Union{Date,DateTime,ZonedDateTime}</code></pre><p>This calculates the integral of a function from a right limit and returns it as a UnivariateFunction. So if you were to then evaluate this integral function at a point x then you would get the integral between right and x.</p><p>If a <code>Date</code>, <code>DateTime</code> is input then it is first converted to a scalar with the <code>zdt2unix</code> function.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>right</code> - A right limit (scalar)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/5_calculus.jl#L63-L78">source</a></section></details></article><h3 id="Interpolation-and-Simplification"><a class="docs-heading-anchor" href="#Interpolation-and-Simplification">Interpolation and Simplification</a><a id="Interpolation-and-Simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-and-Simplification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.create_quadratic_spline"><a class="docstring-binding" href="#UnivariateFunctions.create_quadratic_spline"><code>UnivariateFunctions.create_quadratic_spline</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_quadratic_spline(x::Vector{Q},y::Vector{&lt;:Real} ; gradients::Union{Missing,Vector{&lt;:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),
                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing) where Q&lt;:Union{Date,DateTime,ZonedDateTime}
create_quadratic_spline(x::Vector{&lt;:Real},y::Vector{&lt;:Real} ; gradients::Union{Missing,Vector{&lt;:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),
                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing)
create_quadratic_spline(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}; gradients::Union{Missing,Vector{&lt;:Real}} = missing, extrapolation::Tuple{Schumaker_ExtrapolationSchemes,Schumaker_ExtrapolationSchemes} = (Curve,Curve),
                             left_gradient::Union{Missing,Real} = missing, right_gradient::Union{Missing,Real} = missing) where D&lt;:DatePeriod</code></pre><p>Makes a quadratic shape-preserving interpolation spline using the SchumakerSpline.jl package. This is returned as a <code>Piecewise_Function</code> rather than as a <code>Schumaker</code> struct.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li><li><code>gradients</code> - A <code>Vector</code> with the gradiants at each x location. This is calculated if not provided.</li><li><code>extrapolation</code> - A tuple of enum value describing how to extrapolate (on the left and right sides).</li><li><code>left_gradient</code> - The gradiant to impose on the left edge (ie the first x coordinate).</li><li><code>right_gradient</code> - The gradiant to impose on the right edge (ie the last x coordinate).</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the spline.</li></ul><pre><code class="nohighlight hljs">create_quadratic_spline(schum::Schumaker)</code></pre><p>This converts a spline represented by a <code>SchumakerSpline.Schumaker</code> struct into the same spline but represented by a <code>Piecewise_Function</code>.</p><p><strong>Inputs</strong></p><ul><li><code>schum</code> - A <code>Schumaker</code> struct.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.create_constant_interpolation_to_right"><a class="docstring-binding" href="#UnivariateFunctions.create_constant_interpolation_to_right"><code>UnivariateFunctions.create_constant_interpolation_to_right</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_constant_interpolation_to_right(x::Vector{Date},y::Vector{&lt;:Real})
create_constant_interpolation_to_right(x::Vector{&lt;:Real},y::Vector{&lt;:Real})
create_constant_interpolation_to_right(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}) where D&lt;:DatePeriod</code></pre><p>Makes a piecewise constant interpolation function. values from the left are copied to the right.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the interpolation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L60-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.create_constant_interpolation_to_left"><a class="docstring-binding" href="#UnivariateFunctions.create_constant_interpolation_to_left"><code>UnivariateFunctions.create_constant_interpolation_to_left</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_constant_interpolation_to_left(x::Vector{Date},y::Vector{&lt;:Real})
create_constant_interpolation_to_left(x::Vector{&lt;:Real},y::Vector{&lt;:Real})
create_constant_interpolation_to_left(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}) where D&lt;:DatePeriod</code></pre><p>Makes a piecewise constant interpolation function. values from the right are copied to the left.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the interpolation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L89-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.create_linear_interpolation"><a class="docstring-binding" href="#UnivariateFunctions.create_linear_interpolation"><code>UnivariateFunctions.create_linear_interpolation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_linear_interpolation(x::Vector{Date},y::Vector{&lt;:Real})
create_linear_interpolation(x::Union{Vector{D},Vector{&lt;:DatePeriod}},y::Vector{&lt;:Real}) where D&lt;:DatePeriod
create_linear_interpolation(x::Vector{R},y::Vector{&lt;:Real}) where R&lt;:Real</code></pre><p>Makes a piecewise linear interpolation function. This is continuous.</p><p><strong>Inputs</strong></p><ul><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>y</code> - A <code>Vector</code> with the y coordinates</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code> containing the interpolation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L118-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.simplify"><a class="docstring-binding" href="#UnivariateFunctions.simplify"><code>UnivariateFunctions.simplify</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplify(f::Piecewise_Function, n_points::Integer, left::Real, right::Real, method::Symbol = :linear)
simplify(f::Piecewise_Function, n_points::Integer, left::Q, right::Q, method::Symbol = :linear) where Q&lt;:Union{Date,DateTime,ZonedDateTime}</code></pre><p>Approximates a <code>Piecewise_Function</code> with a simpler one by evaluating at <code>n_points</code> evenly spaced points over <code>[left, right]</code> and re-interpolating.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>Piecewise_Function</code> to simplify.</li><li><code>n_points</code> - The number of evenly spaced sample points.</li><li><code>left</code> - The left boundary of the domain.</li><li><code>right</code> - The right boundary of the domain.</li><li><code>method</code> - The interpolation method. One of <code>:constant_right</code>, <code>:constant_left</code>, <code>:linear</code>, <code>:quadratic</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L160-L176">source</a></section></details></article><h3 id="Iterative-Fitting"><a class="docs-heading-anchor" href="#Iterative-Fitting">Iterative Fitting</a><a id="Iterative-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Fitting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.UnivariateFitter"><a class="docstring-binding" href="#UnivariateFunctions.UnivariateFitter"><code>UnivariateFunctions.UnivariateFitter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnivariateFitter</code></pre><p>A mutable struct for iteratively fitting univariate functions with shape constraints. Each call to <code>fit!</code> fits new data and optionally blends with the previous fit via <code>weight_on_new</code>. Periodic simplification reduces the complexity of the accumulated <code>Piecewise_Function</code>.</p><p><strong>Fields</strong></p><ul><li><code>fun</code> - The current fitted <code>UnivariateFunction</code>.</li><li><code>method</code> - Fitting method. One of <code>:increasing</code>, <code>:decreasing</code>, <code>:convex</code>, <code>:concave</code>, <code>:quasiconvex</code>, <code>:quasiconcave</code>, <code>:supersmoother</code>.</li><li><code>times_through</code> - Number of times <code>fit!</code> has been called.</li><li><code>simplification_frequency</code> - Simplify the function every this many calls to <code>fit!</code>. <code>0</code> disables simplification.</li><li><code>nbins</code> - Number of bins for the regression and for simplification.</li><li><code>equally_spaced_bins</code> - If <code>true</code>, bins are equally spaced in x; if <code>false</code>, based on observation quantiles.</li><li><code>weight_on_new</code> - Blending weight in <code>[0,1]</code>. <code>1.0</code> means only the new fit is used; lower values blend with the previous fit.</li><li><code>left_</code> - Left boundary for simplification domain.</li><li><code>right_</code> - Right boundary for simplification domain.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">UnivariateFitter(method::Symbol; nbins=10, equally_spaced_bins=true,
                 weight_on_new=1.0, simplification_frequency=0,
                 left=-Inf, right=Inf)</code></pre><p>Creates a <code>UnivariateFitter</code> initialised with a zero function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L201-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.fit!"><a class="docstring-binding" href="#UnivariateFunctions.fit!"><code>UnivariateFunctions.fit!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit!(fitter::UnivariateFitter, x_new, y_new)</code></pre><p>Fit the <code>UnivariateFitter</code> to new data <code>x_new</code>, <code>y_new</code>. The fitted function is blended with the previous fit according to <code>fitter.weight_on_new</code>. If <code>simplification_frequency &gt; 0</code> and the current iteration is a multiple, the function is simplified via resampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/6_splines_and_interpolation.jl#L253-L259">source</a></section></details></article><h3 id="Approximation"><a class="docs-heading-anchor" href="#Approximation">Approximation</a><a id="Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.create_ols_approximation"><a class="docstring-binding" href="#UnivariateFunctions.create_ols_approximation"><code>UnivariateFunctions.create_ols_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_ols_approximation(y::Vector{&lt;:Real}, x::Vector{&lt;:Real}, base_x::Real = 0.0, degree::Integer = 1, intercept::Bool = true)
create_ols_approximation(y::Vector{&lt;:Real}, x::Vector{Q}, base_x::Union{Date,DateTime} = global_base_date, degree::Integer = 1, intercept::Bool = true) where Q&lt;:Union{Date,DateTime,ZonedDateTime}</code></pre><p>An approximation function calculated via OLS.</p><p><strong>Inputs</strong></p><ul><li><code>y</code> - A <code>Vector</code> with the y coordinates</li><li><code>x</code> - A <code>Vector</code> with the x coordinates</li><li><code>base_x</code> - A real that offsets the x. So a coordinate with x value of 2.0 will be converted to 1.8 if base_x is 0.2.</li><li><code>degree</code> - What the highest power of x should be. So if this is 3 then the equation will have x, x^2, x^3 as predictors.</li><li><code>intercept</code> - Should there be an x intercept.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Sum_Of_Functions</code> containing the approximation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/7_regressions_and_approximation.jl#L2-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.create_chebyshev_approximation"><a class="docstring-binding" href="#UnivariateFunctions.create_chebyshev_approximation"><code>UnivariateFunctions.create_chebyshev_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_chebyshev_approximation(func::Function, nodes::Integer, degree::Integer, left::Real, right::Real)</code></pre><p>An function that will approximate another function via Chebyshev polynomials.</p><p><strong>Inputs</strong></p><ul><li><code>func</code> - A function that you want to approximation</li><li><code>nodes</code> - The number of approximation nodes</li><li><code>degree</code> - The degree of the Chebyshev polynomials.</li><li><code>left</code> - The left limit of the approximation</li><li><code>right</code> - The right limit of the approximation.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Sum_Of_Functions</code> containing the approximation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/7_regressions_and_approximation.jl#L59-L72">source</a></section></details></article><h3 id="Smoothing"><a class="docs-heading-anchor" href="#Smoothing">Smoothing</a><a id="Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.supersmoother"><a class="docstring-binding" href="#UnivariateFunctions.supersmoother"><code>UnivariateFunctions.supersmoother</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">supersmoother(x::Vector{R}, y::Vector{R}; 
              spans::Vector{R} = [0.05, 0.2, 0.5],
              bass::R = 0.0) where R&lt;:Real</code></pre><p>Friedman&#39;s SuperSmoother (1984) - a local linear regression with adaptive bandwidth.</p><p>Returns a <code>Piecewise_Function</code> (linear interpolation of smoothed values).</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Independent variable values</li><li><code>y</code>: Dependent variable values  </li><li><code>spans</code>: Candidate spans to consider (fraction of data points). Default <code>[0.05, 0.2, 0.5]</code></li><li><code>bass</code>: Bass enhancement (0-10). Higher values favor smoother fits. Default <code>0.0</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">f = supersmoother(x, y)
f(2.5)  # evaluate at new point
derivative(f)  # get derivative function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/9_supersmoother.jl#L189-L210">source</a></section></details></article><h3 id="Monotonic-Regression"><a class="docs-heading-anchor" href="#Monotonic-Regression">Monotonic Regression</a><a id="Monotonic-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Monotonic-Regression" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.isotonic_regression"><a class="docstring-binding" href="#UnivariateFunctions.isotonic_regression"><code>UnivariateFunctions.isotonic_regression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isotonic_regression(x, y; increasing=true)</code></pre><p>Fit an isotonic (monotonic step function) regression using the Pool Adjacent Violators (PAV) algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Independent variable values</li><li><code>y</code>: Dependent variable values</li><li><code>increasing</code>: If <code>true</code>, fit monotonically increasing function; if <code>false</code>, decreasing. Default <code>true</code></li></ul><p>Returns a <code>Piecewise_Function</code> representing the isotonic fit.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = collect(1.0:10.0)
y = x .+ randn(10)
fit = isotonic_regression(x, y; increasing=true)
fit(5.5)  # evaluate at new point</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/8_isotonic_regressions.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.monotonic_regression"><a class="docstring-binding" href="#UnivariateFunctions.monotonic_regression"><code>UnivariateFunctions.monotonic_regression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">monotonic_regression(x, y; nbins=10, equally_spaced_bins=true, increasing=true)</code></pre><p>Fit a piecewise linear monotonic regression using nonnegative least squares.</p><p>This method divides the x-domain into bins and fits a piecewise linear function with nonnegative slopes (for increasing) or nonpositive slopes (for decreasing).</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Independent variable values</li><li><code>y</code>: Dependent variable values</li><li><code>nbins</code>: Number of bins for the piecewise linear fit. Default <code>10</code></li><li><code>equally_spaced_bins</code>: If <code>true</code>, bins are equally spaced in x; if <code>false</code>, based on observation quantiles. Default <code>true</code></li><li><code>increasing</code>: If <code>true</code>, fit monotonically increasing function; if <code>false</code>, decreasing. Default <code>true</code></li></ul><p>Returns a <code>Piecewise_Function</code> representing the monotonic fit.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = collect(range(0, 5, length=100))
y = sqrt.(x) .+ 0.1 .* randn(100)
fit = monotonic_regression(x, y; nbins=15, increasing=true)
fit(2.5)  # evaluate at new point
derivative(fit)  # get derivative function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/8_isotonic_regressions.jl#L108-L133">source</a></section></details></article><h3 id="Unimodal-Regression"><a class="docs-heading-anchor" href="#Unimodal-Regression">Unimodal Regression</a><a id="Unimodal-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Unimodal-Regression" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.unimodal_regression"><a class="docstring-binding" href="#UnivariateFunctions.unimodal_regression"><code>UnivariateFunctions.unimodal_regression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unimodal_regression(x, y; nbins=10, equally_spaced_bins=true, convex=false, quasi=true)</code></pre><p>Fit a unimodal regression function to the data.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Independent variable values</li><li><code>y</code>: Dependent variable values</li><li><code>nbins</code>: Number of bins for piecewise linear fit</li><li><code>equally_spaced_bins</code>: If true, bins are equally spaced; if false, based on observation quantiles</li><li><code>convex</code>: If false, fits concave/quasiconcave (single maximum); if true, fits convex/quasiconvex (single minimum)</li><li><code>quasi</code>: If true, only enforces unimodality (slopes change sign once); if false, also enforces curvature</li></ul><p><strong>Shape constraints:</strong></p><ul><li><code>convex=false, quasi=true</code>:  Quasiconcave - slopes go from + to - (single peak)</li><li><code>convex=true,  quasi=true</code>:  Quasiconvex  - slopes go from - to + (single trough)</li><li><code>convex=false, quasi=false</code>: Concave - slopes monotonically decrease</li><li><code>convex=true,  quasi=false</code>: Convex  - slopes monotonically increase</li></ul><p>Returns a <code>Piecewise_Function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L50-L70">source</a></section></details></article><h3 id="Cross-Validation-Model-Selection"><a class="docs-heading-anchor" href="#Cross-Validation-Model-Selection">Cross-Validation Model Selection</a><a id="Cross-Validation-Model-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-Validation-Model-Selection" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.cv_monotonic_regression"><a class="docstring-binding" href="#UnivariateFunctions.cv_monotonic_regression"><code>UnivariateFunctions.cv_monotonic_regression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cv_monotonic_regression(x, y; nbins=10, equally_spaced_bins=true, nfolds=10, seed=nothing)</code></pre><p>Fit monotonic regression, automatically selecting increasing vs decreasing based on k-fold cross-validation error.</p><p>Returns a <code>CVRegressionResult</code> containing:</p><ul><li><code>fitted</code>: The fitted function (using full dataset)</li><li><code>selected_shape</code>: Either <code>:increasing</code> or <code>:decreasing</code></li><li><code>cv_errors</code>: Dict mapping each shape to its CV error</li><li><code>nfolds</code>: Number of folds used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L275-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.cv_unimodal_regression"><a class="docstring-binding" href="#UnivariateFunctions.cv_unimodal_regression"><code>UnivariateFunctions.cv_unimodal_regression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cv_unimodal_regression(x, y; nbins=10, equally_spaced_bins=true, nfolds=10, seed=nothing)</code></pre><p>Fit unimodal regression, automatically selecting among:</p><ul><li><code>:quasiconcave</code> (convex=false, quasi=true)</li><li><code>:quasiconvex</code>  (convex=true,  quasi=true)</li><li><code>:concave</code>      (convex=false, quasi=false)</li><li><code>:convex</code>       (convex=true,  quasi=false)</li></ul><p>based on k-fold cross-validation error.</p><p>Returns a <code>CVRegressionResult</code> containing:</p><ul><li><code>fitted</code>: The fitted function (using full dataset)</li><li><code>selected_shape</code>: One of the four shape symbols</li><li><code>cv_errors</code>: Dict mapping each shape to its CV error</li><li><code>nfolds</code>: Number of folds used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L331-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.cv_shape_regression"><a class="docstring-binding" href="#UnivariateFunctions.cv_shape_regression"><code>UnivariateFunctions.cv_shape_regression</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cv_shape_regression(x, y; shapes=:all, nbins=10, equally_spaced_bins=true, nfolds=10, seed=nothing)</code></pre><p>Fit regression with automatic shape selection via cross-validation.</p><p><code>shapes</code> can be:</p><ul><li><code>:monotonic</code> - choose between increasing/decreasing</li><li><code>:unimodal</code>  - choose between quasiconcave/quasiconvex/concave/convex</li><li><code>:all</code>       - choose from all 6 shapes</li><li>A vector of symbols, e.g. <code>[:increasing, :quasiconcave, :convex]</code></li></ul><p>Available shapes: <code>:increasing</code>, <code>:decreasing</code>, <code>:quasiconcave</code>, <code>:quasiconvex</code>, <code>:concave</code>, <code>:convex</code></p><p>Returns a <code>CVRegressionResult</code> with the fitted function and selection metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L396-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.CVRegressionResult"><a class="docstring-binding" href="#UnivariateFunctions.CVRegressionResult"><code>UnivariateFunctions.CVRegressionResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CVRegressionResult{F&lt;:UnivariateFunction}</code></pre><p>Result type for cross-validated regression model selection.</p><p><strong>Fields</strong></p><ul><li><code>fitted::F</code>: The fitted <code>UnivariateFunction</code> (typically a <code>Piecewise_Function</code>)</li><li><code>selected_shape::Symbol</code>: The shape that was selected (e.g., <code>:increasing</code>, <code>:quasiconcave</code>)</li><li><code>cv_errors::Dict{Symbol, Float64}</code>: Cross-validation errors for each candidate shape</li><li><code>nfolds::Int</code>: Number of folds used in cross-validation</li></ul><p>The result is callable - you can use it directly as a function:</p><pre><code class="language-julia hljs">result = cv_shape_regression(x, y)
result(2.5)  # equivalent to result.fitted(2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L248-L264">source</a></section></details></article><h3 id="Internal-Functions-2"><a class="docs-heading-anchor" href="#Internal-Functions-2">Internal Functions</a><a class="docs-heading-anchor-permalink" href="#Internal-Functions-2" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.change_base_of_PE_Function"><a class="docstring-binding" href="#UnivariateFunctions.change_base_of_PE_Function"><code>UnivariateFunctions.change_base_of_PE_Function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">change_base_of_PE_Function(f::PE_Function, new_base::Real)</code></pre><p>This changes the base of a <code>PE_Function</code>. So if the base was 2 then it can be converted to 3 with an additional constant term.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>PE_Function</code>.</li><li><code>new_base</code> - The new base.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>PE_Function</code> or a <code>Sum_Of_Functions</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L309-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.trim_piecewise_function"><a class="docstring-binding" href="#UnivariateFunctions.trim_piecewise_function"><code>UnivariateFunctions.trim_piecewise_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trim_piecewise_function(func::Piecewise_Function, left_limit::Real, right_limit::Real)</code></pre><p>This trims the end of a piecewise function. So if there is a piecewise function with support between -10,10 then you can trim it to only have support between -5 and 5. Then if it is evaluated outside -5 to 5 it will be undefined.</p><p><strong>Inputs</strong></p><ul><li><code>func</code> - A Piecewise_Function.</li><li><code>left_limit</code> - The left limit.</li><li><code>right_limit</code> - The right limit.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Piecewise_Function</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L120-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.convert_to_linearly_rescale_inputs"><a class="docstring-binding" href="#UnivariateFunctions.convert_to_linearly_rescale_inputs"><code>UnivariateFunctions.convert_to_linearly_rescale_inputs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">convert_to_linearly_rescale_inputs(f::UnivariateFunction, alpha::Real, beta::Real)</code></pre><p>This alters a function so that whenever we put in x it is like we put in <code>alpha * x + beta</code>.</p><p><strong>Inputs</strong></p><ul><li><code>f</code> - A <code>UnivariateFunction</code>.</li><li><code>alpha</code> - The slope of the rescaling.</li><li><code>beta</code> - The level of the rescaling.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>UnivariateFunction</code> of the type that you input to the function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/0_structs_and_generic_reversals.jl#L348-L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.get_chevyshevs_up_to"><a class="docstring-binding" href="#UnivariateFunctions.get_chevyshevs_up_to"><code>UnivariateFunctions.get_chevyshevs_up_to</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_chevyshevs_up_to(N::Integer, first_kind::Bool = true)</code></pre><p>Get the first N chebyshev polynomials returned as a vector of <code>UnivariateFunction</code>s. The first 20 polynomials of each are precompiled into the binaries for speed. If you need more than that they will be calculated at runtime.</p><p>These can be from either the first kind or second kind polynomial sequence.</p><p><strong>Inputs</strong></p><ul><li><code>N</code> - How many chebyshev polynomials do you want.</li><li><code>first_kind</code> - A Bool. If true you get first kind polynomials. If false you get second kind.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Vector</code> of <code>UnivariateFunction</code>s for each polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/chebyshevs.jl#L22-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions._kfold_indices"><a class="docstring-binding" href="#UnivariateFunctions._kfold_indices"><code>UnivariateFunctions._kfold_indices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_kfold_indices(n::Int, nfolds::Int; seed::Union{Int,Nothing}=nothing)</code></pre><p>Generate random fold assignments for k-fold CV. Returns a vector of length n with values 1:nfolds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions._cv_error"><a class="docstring-binding" href="#UnivariateFunctions._cv_error"><code>UnivariateFunctions._cv_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_cv_error(x, y, fold_indices, fit_func; kwargs...)</code></pre><p>Compute total cross-validation SSE for a given fitting function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/10_unimodals.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions._local_linear_smooth"><a class="docstring-binding" href="#UnivariateFunctions._local_linear_smooth"><code>UnivariateFunctions._local_linear_smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_local_linear_smooth(x::Vector{R}, y::Vector{R}, span::R) where R&lt;:Real</code></pre><p>Compute local linear regression smoothed values for all points. <code>span</code> is the fraction of data points to use in each local fit (0 &lt; span ≤ 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/9_supersmoother.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions._local_linear_loo_residuals"><a class="docstring-binding" href="#UnivariateFunctions._local_linear_loo_residuals"><code>UnivariateFunctions._local_linear_loo_residuals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_local_linear_loo_residuals(x::Vector{R}, y::Vector{R}, span::R) where R&lt;:Real</code></pre><p>Compute leave-one-out residuals for local linear regression at given span. Returns |yᵢ - ŷ₋ᵢ| for each point (prediction without using point i).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/9_supersmoother.jl#L46-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions._smooth_values"><a class="docstring-binding" href="#UnivariateFunctions._smooth_values"><code>UnivariateFunctions._smooth_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_smooth_values(x::Vector{R}, v::Vector{R}, span::R) where R&lt;:Real</code></pre><p>Smooth a vector v using local mean with given span. Used to smooth the span selection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/9_supersmoother.jl#L93-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions._supersmoother_values"><a class="docstring-binding" href="#UnivariateFunctions._supersmoother_values"><code>UnivariateFunctions._supersmoother_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_supersmoother_values(x::Vector{R}, y::Vector{R}; 
                      spans::Vector{R} = [0.05, 0.2, 0.5],
                      bass::R = 0.0) where R&lt;:Real</code></pre><p>Core SuperSmoother algorithm. Returns smoothed y values.</p><ul><li><code>spans</code>: The three candidate spans to try (fraction of data)</li><li><code>bass</code>: Bass enhancement parameter (0-10). Higher values produce smoother results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/9_supersmoother.jl#L112-L121">source</a></section></details></article><h3 id="Date-Conversions"><a class="docs-heading-anchor" href="#Date-Conversions">Date Conversions</a><a id="Date-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Date-Conversions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="UnivariateFunctions.seconds_between"><a class="docstring-binding" href="#UnivariateFunctions.seconds_between"><code>UnivariateFunctions.seconds_between</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seconds_between(a::Union{ZonedDateTime,DateTime,Date}, b::Union{ZonedDateTime,DateTime,Date})</code></pre><p>The number of seconds between two dates. This is the delta between two unixtimes.</p><p><strong>Inputs</strong></p><ul><li><code>a</code> - The end date</li><li><code>b</code> - The start date.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L122-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.days_between"><a class="docstring-binding" href="#UnivariateFunctions.days_between"><code>UnivariateFunctions.days_between</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">days_between(a, b)</code></pre><p>The number of days between two dates. Computed as <code>seconds_between(a, b) / 86400</code>.</p><p><strong>Inputs</strong></p><ul><li><code>a</code> - The end date (ZonedDateTime, DateTime, or Date)</li><li><code>b</code> - The start date (ZonedDateTime, DateTime, or Date)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code> representing the number of days (can be fractional).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">days_between(Date(2020, 1, 11), Date(2020, 1, 1))  # 10.0
days_between(DateTime(2020, 1, 1, 12, 0, 0), DateTime(2020, 1, 1, 0, 0, 0))  # 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L136-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.years_between"><a class="docstring-binding" href="#UnivariateFunctions.years_between"><code>UnivariateFunctions.years_between</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">years_between(a, b)</code></pre><p>The number of years between two dates. Computed as <code>seconds_between(a, b) / (365.25 * 86400)</code>.</p><p><strong>Inputs</strong></p><ul><li><code>a</code> - The end date (ZonedDateTime, DateTime, or Date)</li><li><code>b</code> - The start date (ZonedDateTime, DateTime, or Date)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code> representing the number of years (can be fractional).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">years_between(Date(2021, 1, 1), Date(2020, 1, 1))  # approximately 1.0
years_between(Date(2020, 7, 1), Date(2020, 1, 1))  # approximately 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L158-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.period_length"><a class="docstring-binding" href="#UnivariateFunctions.period_length"><code>UnivariateFunctions.period_length</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">period_length(a::Dates.DatePeriod, base::Date = global_base_date)</code></pre><p>Period length is designed to convert <code>TimePeriod</code> objects to a float in a consistent way to <code>zdt2unix</code>. So effectively the seconds_between method is calculated with start and end dates being those at the start and end of a <code>Dates.DatePeriod</code>. This is slightly complicated because a period like <code>Month(3)</code> might have slightly different numbers of total days depending on when in the year it is. So a base date has to be input. The period is then measured starting from this base date.</p><p><strong>Inputs</strong></p><ul><li><code>period</code> - A period.</li><li><code>base</code> - A date from which the period will be measured from.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L182-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.years_from_global_base_date"><a class="docstring-binding" href="#UnivariateFunctions.years_from_global_base_date"><code>UnivariateFunctions.years_from_global_base_date</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">years_from_global_base_date(a)</code></pre><p>The number of years between a date and the global base date (1970-01-01 00:00:00 UTC).</p><p>This is used internally to convert dates to floats for use in <code>PE_Function</code> bases.</p><p><strong>Inputs</strong></p><ul><li><code>a</code> - A <code>ZonedDateTime</code>, <code>DateTime</code>, or <code>Date</code></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Real</code> representing the number of years since 1970-01-01.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">years_from_global_base_date(Date(1970, 1, 1))  # 0.0
years_from_global_base_date(Date(2020, 1, 1))  # approximately 50.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L202-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.zdt2unix"><a class="docstring-binding" href="#UnivariateFunctions.zdt2unix"><code>UnivariateFunctions.zdt2unix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zdt2unix(d)</code></pre><p>Convert a <code>ZonedDateTime</code>, <code>DateTime</code>, or <code>Date</code> to Unix timestamp (seconds since 1970-01-01 00:00:00 UTC).</p><p><strong>Inputs</strong></p><ul><li><code>d</code> - A <code>ZonedDateTime</code>, <code>DateTime</code>, <code>Date</code>, or <code>missing</code></li></ul><p><strong>Returns</strong></p><ul><li>An <code>Int</code> representing seconds since Unix epoch, or <code>missing</code> if input is missing.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">zdt2unix(Date(2020, 1, 1))  # 1577836800
zdt2unix(DateTime(2020, 1, 1, 12, 0, 0))  # 1577880000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L90-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.unix2zdt"><a class="docstring-binding" href="#UnivariateFunctions.unix2zdt"><code>UnivariateFunctions.unix2zdt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unix2zdt(seconds_since_1970, tzz=tz&quot;UTC&quot;)</code></pre><p>Convert Unix timestamp (seconds since 1970-01-01 00:00:00 UTC) to a <code>ZonedDateTime</code>.</p><p><strong>Inputs</strong></p><ul><li><code>seconds_since_1970</code> - Unix timestamp as Integer, Real, or missing</li><li><code>tzz</code> - Timezone (default: UTC)</li></ul><p><strong>Returns</strong></p><ul><li>A <code>ZonedDateTime</code>, or <code>missing</code> if input is missing.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">unix2zdt(1577836800)  # 2020-01-01T00:00:00+00:00
unix2zdt(0, tz&quot;America/New_York&quot;)  # 1969-12-31T19:00:00-05:00</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.unix2dt"><a class="docstring-binding" href="#UnivariateFunctions.unix2dt"><code>UnivariateFunctions.unix2dt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unix2dt(seconds_since_1970)</code></pre><p>Convert Unix timestamp (seconds since 1970-01-01 00:00:00 UTC) to a <code>DateTime</code>.</p><p><strong>Inputs</strong></p><ul><li><code>seconds_since_1970</code> - Unix timestamp as Integer, Real, or missing</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DateTime</code>, or <code>missing</code> if input is missing.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">unix2dt(1577836800)  # 2020-01-01T00:00:00</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L26-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="UnivariateFunctions.unix2d"><a class="docstring-binding" href="#UnivariateFunctions.unix2d"><code>UnivariateFunctions.unix2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unix2d(seconds_since_1970)</code></pre><p>Convert Unix timestamp (seconds since 1970-01-01 00:00:00 UTC) to a <code>Date</code>.</p><p><strong>Inputs</strong></p><ul><li><code>seconds_since_1970</code> - Unix timestamp as Integer, Real, or missing</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Date</code>, or <code>missing</code> if input is missing.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">unix2d(1577836800)  # 2020-01-01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-baumann/UnivariateFunctions.jl/blob/6637e42918020df1ceafa667da03f8d025b649a1/src/date_conversions.jl#L49-L64">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Regression/">« Regression and Smoothing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 8 February 2026 10:53">Sunday 8 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
